/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _traceroute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./traceroute */ \"./src/traceroute.js\");\n/* harmony import */ var _location__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./location */ \"./src/location.js\");\n/* harmony import */ var _maps__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./maps */ \"./src/maps.js\");\n/* harmony import */ var regenerator_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n/* harmony import */ var regenerator_runtime__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\n//Sets getStarted to the get-started HTML elements\nconst getStarted = document.getElementById(\"get-started\");\nconst macbook = document.getElementById(\"macbook-container\");\n\n//Listens for a click on the get-started button\n//To summ. this hides the homepage and shows the enter destination container\ngetStarted.addEventListener('click', event => {\n  //prevents the default of loading a page on click\n  event.preventDefault();\n  //saves the HTML container welcome container\n  const welcomePage = document.getElementById(\"welcome-container\");\n  //saves the HTNL container destinations\n  const enterDestination = document.getElementById(\"destinations\");\n  //Adds hidden to the HTML container \n  welcomePage.classList.add('hidden');\n  //Rmoeves hidden from the HTML container destination\n  enterDestination.classList.remove('hidden');\n  //Removes hidden from the HTML container macbook-container\n  macbook.classList.remove('hidden');\n});\nconst letsGo = document.getElementById(\"domain-submit\");\n\n//Summarize, this function waits for this for lets go to be clicked\n//Hides HTML elements, shows the destinations details container\n//Gathers user input and passes it to routes function\nconst spinner = document.getElementById(\"spinner\");\nletsGo.addEventListener('click', event => {\n  const domainInput = document.getElementById(\"domain\").value;\n  if (domainInput === \"\") {\n    alert(\"Please enter a domain name, i.e. google.com, facebook.com, twitter.com, etc.\");\n    return;\n  }\n  event.preventDefault();\n  const enterDestination = document.getElementById(\"enter-destination\");\n  // const destinationDetails = document.getElementById(\"destination-details\")\n  enterDestination.classList.add('hidden');\n  macbook.classList.add('hidden');\n  spinner.classList.remove('hidden');\n  // destinationDetails.classList.remove('hidden')\n  // domainInput = document.getElementById(\"domain\").value\n\n  // console.log(domainInput)\n  routes(domainInput);\n});\n\n// window.domainInput = domainInput\n\n//makes a new traceroute instance\nconst traceRoute = new _traceroute__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n//array of collected IP from the routes function\nlet ipTest = ['0.0.0.0', '0.0.0.0', 'ae2.3612.edge6.Washington12.level3.net', '4.68.38.6', '129.134.99.222', '173.252.67.63'];\nlet ip_collection = [];\nconst hasAlphaCharacters = function (ip) {\n  if (ip.match(/[a-z]/i)) {\n    return true;\n  }\n};\nconst validIP = function (ip) {\n  if (ip === \"0.0.0.0\" || ip === \"*\") {\n    return false;\n  } else if (hasAlphaCharacters(ip)) {\n    return false;\n  } else {\n    return true;\n  }\n};\n\n//Summarize, takes domain input from the Lets go event listener\n//calls the class function getRoute and passes the domain input\n//get route is an API fetch and passes each hop into \n//calls the locate details function when done\nconst routes = function (domain) {\n  const route = traceRoute.getRoute(domain);\n  route.then(data => {\n    // console.log(data.response.hops, \"hops console log\")\n    for (let number in data.response.hops) {\n      if (validIP(data.response.hops[number].ip)) {\n        ip_collection.push(data.response.hops[number].ip);\n      }\n    }\n    locateDetails();\n  });\n};\n\n// const routes = function(domain){\n//     for (let i=0; i < ipTest.length; i++){\n//         if (validIP(ipTest[i])){\n//             ip_collection.push(ipTest[i])\n//         }\n//     }\n//     locateDetails()\n// }\n\n// window.ip_collection = ip_collection\n\n//working API call to gather IP geo location details\nconst locate = new _location__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\nlet listCities = [];\nlet listLongitude = [];\nlet listLatitude = [];\n\n// window.listCities = listCities\n// window.listLongitude = listLongitude\n// window.listLatitude = listLatitude\n\n//iterates through array of collected IPs\n//due to API restrictions each API call from getLocation\n//must wait one second per request\n//adds API data into an \n\nfunction locateDetails() {\n  const destinationDetails = document.getElementById(\"destination-details\");\n  for (let i = 0; i < ip_collection.length; i++) {\n    // setTimeout(() => {\n    let geolocation = locate.getLocation(ip_collection[i]);\n    geolocation.then(data => {\n      console.log(data);\n      console.log(data.loc);\n      let location = data.loc.split(',');\n      listCities.push(data.city);\n      listLatitude.push(parseFloat(location[0]));\n      listLongitude.push(parseFloat(location[1]));\n      console.log(location);\n\n      // if (!listLongitude.includes(data.longitude)){\n      //     listCities.push(data.city)\n      //     listLongitude.push(data.longitude)\n      //     listLatitude.push(data.latitude)\n      //     console.log(ip_collection)\n      //     console.log(listCities)\n      if (listCities.length === ip_collection.length) {\n        spinner.classList.add('hidden');\n        destinationDetails.classList.remove('hidden');\n        macbook.classList.remove('hidden');\n        destinationH1.innerHTML = `You've arrive at ${listCities[0]}`;\n        makeMap();\n      }\n      // }\n    });\n    // },i * 1500)\n  }\n}\n\n// window.locateDetails = locateDetails\n\n//Makes a map as an instance of Map\n//Takes in the first positions from listLatitude and listLongitude\n//Create a new script HTML element\n//Fetches the google maps API key from the proxy server\n//Sets the new script src to equal our google maps API call\n//Google maps API requires a callback function, hence map.initMap\nlet map;\nfunction makeMap() {\n  map = new _maps__WEBPACK_IMPORTED_MODULE_2__[\"default\"](listLatitude[0], listLongitude[0]);\n  map.initMap;\n  let script = document.createElement('script');\n  //setting src html tag equal to my google API Call\n  // fetch(\"https://mapping-the-matrix.onrender.com/goog\").then(res => {\n  fetch(\"http://localhost:5001/goog\").then(res => {\n    return res.text();\n  }).then(key => {\n    // console.log(key)\n    script.src = `https://maps.googleapis.com/maps/api/js?key=${key}&callback=map.initMap`;\n  });\n  //setting async true on our HTML element\n  script.async = true;\n  //adding html element to our head section of our HTML document\n  document.head.appendChild(script);\n  //setting map on the window\n  window.map = map;\n}\n\n//Listens for next-button click\n//On button click increment i by 1\n//Set the arrived destination to the updated city\n//update the map and marker to updated coordinates\n//if we've reached the end we provide summary view of all mapped location\nlet i = 0;\nlet destinationH1 = document.getElementById(\"destination\");\ndestinationH1.innerHTML = `You've arrived at ${listCities[i]}`;\nconst nextButton = document.getElementById(\"next-button\");\nconst onNextClick = function (event) {\n  event.preventDefault();\n  i += 1;\n  destinationH1.innerHTML = `You've arrived at ${listCities[i]}`;\n  map.updateMapAndMarkerPosition(listLatitude[i], listLongitude[i]);\n  if (i === listLatitude.length) {\n    destinationH1.innerHTML = \"Your Mapped Matrix\";\n    map.addMarkers(listLatitude, listLongitude);\n    nextButton.removeEventListener('click', onNextClick);\n  }\n};\nnextButton.addEventListener('click', onNextClick);\n\n//set canvas to to HTML canvas element\nconst canvas = document.getElementById(\"canvas\");\nconst ctx = canvas.getContext(\"2d\");\n//set canvas to the current window width and height\ncanvas.width = window.innerWidth;\ncanvas.height = window.innerHeight;\n//color and font style\nctx.fillStyle = \"#0F0\";\nctx.font = \"16px monospace\";\nconst chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\nconst charArr = chars.split(\"\");\n//number of columns needed based on the width of the window\nconst columns = canvas.width / 16;\nlet drops = [];\n//set each element in column equal to 1\nfor (let i = 0; i < columns; i++) {\n  drops[i] = 1;\n}\nfunction draw() {\n  //set canvas to semi-transparent black\n  ctx.fillStyle = \"rgba(0, 0, 0, 0.05)\";\n  //draws rectangle based on canvas width and heigh that we set earlier\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\n  //set fillstyle to green\n  ctx.fillStyle = \"#0F0\";\n  for (let i = 0; i < drops.length; i++) {\n    //sets char index to hold a random index up to the char Array length\n    const charIndex = Math.floor(Math.random() * charArr.length);\n    //set char to the random char\n    const char = charArr[charIndex];\n    //fills text\n    ctx.fillText(char, i * 16, drops[i] * 16);\n    //resets drop back to 0, otherwise increment\n    if (drops[i] * 16 > canvas.height && Math.random() > 0.95) {\n      drops[i] = 0;\n    }\n    drops[i]++;\n  }\n}\n\n//resizes the canvas based on the state of the window and height\nfunction resizeCanvas() {\n  canvas.width = window.innerWidth;\n  canvas.height = window.innerHeight;\n  const columns = canvas.width / 16;\n  drops = [];\n  for (let i = 0; i < columns; i++) {\n    drops[i] = 1;\n  }\n}\n\n//listening for window resize, runs callback if it does\nwindow.addEventListener('resize', resizeCanvas);\nresizeCanvas();\ncanvas.addEventListener(\"mousemove\", function (event) {\n  const mouseX = event.clientX - canvas.offsetLeft;\n  const mouseY = event.clientY - canvas.offsetTop;\n  const column = Math.floor(mouseX / 16);\n  const row = Math.floor(mouseY / 16);\n  ctx.fillStyle = \"#ff3333\";\n  for (let i = column - 1; i <= column + 1; i++) {\n    for (let j = row - 1; j <= row + 1; j++) {\n      if (i >= 0 && i < columns && j >= 0 && j < drops.length) {\n        ctx.fillText(charArr[Math.floor(Math.random() * charArr.length)], i * 16, drops[j] * 16);\n      }\n    }\n  }\n});\n\n//draws canvas every 33 miliseconds\nsetInterval(draw, 33);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFBSSxDQUFDRSxNQUFNLEVBQUUsR0FBR1IsT0FBTyxDQUFDeEMsTUFBTSxDQUFDLENBQUMsRUFBRUQsQ0FBQyxHQUFHLEVBQUUsRUFBRTJDLEtBQUssQ0FBQ2tCLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztNQUM1RjtJQUNKO0VBQ0o7QUFDSixDQUFDLENBQUM7O0FBR0Y7QUFDQUMsV0FBVyxDQUFDbEIsSUFBSSxFQUFFLEVBQUUsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcF9tYXRyaXgvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVHJhY2Vyb3V0ZSBmcm9tIFwiLi90cmFjZXJvdXRlXCI7XG5pbXBvcnQgTG9jYXRpb24gZnJvbSBcIi4vbG9jYXRpb25cIjtcbmltcG9ydCBNYXAgZnJvbSBcIi4vbWFwc1wiO1xuaW1wb3J0IHsgYXN5bmMgfSBmcm9tIFwicmVnZW5lcmF0b3ItcnVudGltZVwiO1xuXG4vL1NldHMgZ2V0U3RhcnRlZCB0byB0aGUgZ2V0LXN0YXJ0ZWQgSFRNTCBlbGVtZW50c1xuY29uc3QgZ2V0U3RhcnRlZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZ2V0LXN0YXJ0ZWRcIilcbmNvbnN0IG1hY2Jvb2sgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1hY2Jvb2stY29udGFpbmVyXCIpXG5cbi8vTGlzdGVucyBmb3IgYSBjbGljayBvbiB0aGUgZ2V0LXN0YXJ0ZWQgYnV0dG9uXG4vL1RvIHN1bW0uIHRoaXMgaGlkZXMgdGhlIGhvbWVwYWdlIGFuZCBzaG93cyB0aGUgZW50ZXIgZGVzdGluYXRpb24gY29udGFpbmVyXG5nZXRTdGFydGVkLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgLy9wcmV2ZW50cyB0aGUgZGVmYXVsdCBvZiBsb2FkaW5nIGEgcGFnZSBvbiBjbGlja1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgLy9zYXZlcyB0aGUgSFRNTCBjb250YWluZXIgd2VsY29tZSBjb250YWluZXJcbiAgICBjb25zdCB3ZWxjb21lUGFnZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwid2VsY29tZS1jb250YWluZXJcIilcbiAgICAvL3NhdmVzIHRoZSBIVE5MIGNvbnRhaW5lciBkZXN0aW5hdGlvbnNcbiAgICBjb25zdCBlbnRlckRlc3RpbmF0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkZXN0aW5hdGlvbnNcIilcbiAgICAvL0FkZHMgaGlkZGVuIHRvIHRoZSBIVE1MIGNvbnRhaW5lciBcbiAgICB3ZWxjb21lUGFnZS5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKVxuICAgIC8vUm1vZXZlcyBoaWRkZW4gZnJvbSB0aGUgSFRNTCBjb250YWluZXIgZGVzdGluYXRpb25cbiAgICBlbnRlckRlc3RpbmF0aW9uLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpXG4gICAgLy9SZW1vdmVzIGhpZGRlbiBmcm9tIHRoZSBIVE1MIGNvbnRhaW5lciBtYWNib29rLWNvbnRhaW5lclxuICAgIG1hY2Jvb2suY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJylcbn0pXG5cblxuY29uc3QgbGV0c0dvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkb21haW4tc3VibWl0XCIpXG5cbi8vU3VtbWFyaXplLCB0aGlzIGZ1bmN0aW9uIHdhaXRzIGZvciB0aGlzIGZvciBsZXRzIGdvIHRvIGJlIGNsaWNrZWRcbi8vSGlkZXMgSFRNTCBlbGVtZW50cywgc2hvd3MgdGhlIGRlc3RpbmF0aW9ucyBkZXRhaWxzIGNvbnRhaW5lclxuLy9HYXRoZXJzIHVzZXIgaW5wdXQgYW5kIHBhc3NlcyBpdCB0byByb3V0ZXMgZnVuY3Rpb25cbmNvbnN0IHNwaW5uZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNwaW5uZXJcIilcblxubGV0c0dvLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgZG9tYWluSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRvbWFpblwiKS52YWx1ZVxuICAgIGlmIChkb21haW5JbnB1dCA9PT0gXCJcIil7XG4gICAgICAgIGFsZXJ0KFwiUGxlYXNlIGVudGVyIGEgZG9tYWluIG5hbWUsIGkuZS4gZ29vZ2xlLmNvbSwgZmFjZWJvb2suY29tLCB0d2l0dGVyLmNvbSwgZXRjLlwiKVxuICAgICAgICByZXR1cm5cbiAgICB9XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBlbnRlckRlc3RpbmF0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJlbnRlci1kZXN0aW5hdGlvblwiKVxuICAgIC8vIGNvbnN0IGRlc3RpbmF0aW9uRGV0YWlscyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGVzdGluYXRpb24tZGV0YWlsc1wiKVxuICAgIGVudGVyRGVzdGluYXRpb24uY2xhc3NMaXN0LmFkZCgnaGlkZGVuJylcbiAgICBtYWNib29rLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpXG4gICAgc3Bpbm5lci5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKVxuICAgIC8vIGRlc3RpbmF0aW9uRGV0YWlscy5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKVxuICAgIC8vIGRvbWFpbklucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkb21haW5cIikudmFsdWVcbiAgICBcbiAgICAvLyBjb25zb2xlLmxvZyhkb21haW5JbnB1dClcbiAgICByb3V0ZXMoZG9tYWluSW5wdXQpXG59KVxuXG4vLyB3aW5kb3cuZG9tYWluSW5wdXQgPSBkb21haW5JbnB1dFxuXG4vL21ha2VzIGEgbmV3IHRyYWNlcm91dGUgaW5zdGFuY2VcbmNvbnN0IHRyYWNlUm91dGUgPSBuZXcgVHJhY2Vyb3V0ZVxuLy9hcnJheSBvZiBjb2xsZWN0ZWQgSVAgZnJvbSB0aGUgcm91dGVzIGZ1bmN0aW9uXG5sZXQgaXBUZXN0ID0gWycwLjAuMC4wJywgJzAuMC4wLjAnLCAnYWUyLjM2MTIuZWRnZTYuV2FzaGluZ3RvbjEyLmxldmVsMy5uZXQnLCAnNC42OC4zOC42JywgJzEyOS4xMzQuOTkuMjIyJywgJzE3My4yNTIuNjcuNjMnXVxubGV0IGlwX2NvbGxlY3Rpb24gPSBbXVxuXG5cbmNvbnN0IGhhc0FscGhhQ2hhcmFjdGVycyA9IGZ1bmN0aW9uKGlwKXtcbiAgICBpZiAoaXAubWF0Y2goL1thLXpdL2kpKXtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG59XG5cbmNvbnN0IHZhbGlkSVAgPSBmdW5jdGlvbihpcCl7XG4gICAgaWYgKGlwID09PSBcIjAuMC4wLjBcIiB8fCBpcCA9PT0gXCIqXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIGlmIChoYXNBbHBoYUNoYXJhY3RlcnMoaXApKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG59XG5cblxuXG4vL1N1bW1hcml6ZSwgdGFrZXMgZG9tYWluIGlucHV0IGZyb20gdGhlIExldHMgZ28gZXZlbnQgbGlzdGVuZXJcbi8vY2FsbHMgdGhlIGNsYXNzIGZ1bmN0aW9uIGdldFJvdXRlIGFuZCBwYXNzZXMgdGhlIGRvbWFpbiBpbnB1dFxuLy9nZXQgcm91dGUgaXMgYW4gQVBJIGZldGNoIGFuZCBwYXNzZXMgZWFjaCBob3AgaW50byBcbi8vY2FsbHMgdGhlIGxvY2F0ZSBkZXRhaWxzIGZ1bmN0aW9uIHdoZW4gZG9uZVxuY29uc3Qgcm91dGVzID0gZnVuY3Rpb24oZG9tYWluKXtcbiAgICBjb25zdCByb3V0ZSA9IHRyYWNlUm91dGUuZ2V0Um91dGUoZG9tYWluKVxuICAgIHJvdXRlLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coZGF0YS5yZXNwb25zZS5ob3BzLCBcImhvcHMgY29uc29sZSBsb2dcIilcbiAgICAgICAgZm9yIChsZXQgbnVtYmVyIGluIGRhdGEucmVzcG9uc2UuaG9wcykge1xuICAgICAgICAgICAgaWYgKHZhbGlkSVAoZGF0YS5yZXNwb25zZS5ob3BzW251bWJlcl0uaXApKSB7XG4gICAgICAgICAgICAgICAgaXBfY29sbGVjdGlvbi5wdXNoKGRhdGEucmVzcG9uc2UuaG9wc1tudW1iZXJdLmlwKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxvY2F0ZURldGFpbHMoKVxuICAgIH0pICAgIFxufTtcblxuLy8gY29uc3Qgcm91dGVzID0gZnVuY3Rpb24oZG9tYWluKXtcbi8vICAgICBmb3IgKGxldCBpPTA7IGkgPCBpcFRlc3QubGVuZ3RoOyBpKyspe1xuLy8gICAgICAgICBpZiAodmFsaWRJUChpcFRlc3RbaV0pKXtcbi8vICAgICAgICAgICAgIGlwX2NvbGxlY3Rpb24ucHVzaChpcFRlc3RbaV0pXG4vLyAgICAgICAgIH1cbi8vICAgICB9XG4vLyAgICAgbG9jYXRlRGV0YWlscygpXG4vLyB9XG5cblxuLy8gd2luZG93LmlwX2NvbGxlY3Rpb24gPSBpcF9jb2xsZWN0aW9uXG5cbi8vd29ya2luZyBBUEkgY2FsbCB0byBnYXRoZXIgSVAgZ2VvIGxvY2F0aW9uIGRldGFpbHNcbmNvbnN0IGxvY2F0ZSA9IG5ldyBMb2NhdGlvblxuXG5sZXQgbGlzdENpdGllcyA9IFtdXG5sZXQgbGlzdExvbmdpdHVkZSA9IFtdXG5sZXQgbGlzdExhdGl0dWRlID0gW11cblxuLy8gd2luZG93Lmxpc3RDaXRpZXMgPSBsaXN0Q2l0aWVzXG4vLyB3aW5kb3cubGlzdExvbmdpdHVkZSA9IGxpc3RMb25naXR1ZGVcbi8vIHdpbmRvdy5saXN0TGF0aXR1ZGUgPSBsaXN0TGF0aXR1ZGVcblxuLy9pdGVyYXRlcyB0aHJvdWdoIGFycmF5IG9mIGNvbGxlY3RlZCBJUHNcbi8vZHVlIHRvIEFQSSByZXN0cmljdGlvbnMgZWFjaCBBUEkgY2FsbCBmcm9tIGdldExvY2F0aW9uXG4vL211c3Qgd2FpdCBvbmUgc2Vjb25kIHBlciByZXF1ZXN0XG4vL2FkZHMgQVBJIGRhdGEgaW50byBhbiBcblxuZnVuY3Rpb24gbG9jYXRlRGV0YWlscygpe1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uRGV0YWlscyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGVzdGluYXRpb24tZGV0YWlsc1wiKVxuICAgIGZvciAobGV0IGk9MCA7IGkgPCBpcF9jb2xsZWN0aW9uLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgLy8gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBsZXQgZ2VvbG9jYXRpb24gPSBsb2NhdGUuZ2V0TG9jYXRpb24oaXBfY29sbGVjdGlvbltpXSlcbiAgICAgICAgICAgIGdlb2xvY2F0aW9uLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEubG9jKVxuICAgICAgICAgICAgICAgIGxldCBsb2NhdGlvbiA9IGRhdGEubG9jLnNwbGl0KCcsJylcbiAgICAgICAgICAgICAgICBsaXN0Q2l0aWVzLnB1c2goZGF0YS5jaXR5KVxuICAgICAgICAgICAgICAgIGxpc3RMYXRpdHVkZS5wdXNoKHBhcnNlRmxvYXQobG9jYXRpb25bMF0pKVxuICAgICAgICAgICAgICAgIGxpc3RMb25naXR1ZGUucHVzaChwYXJzZUZsb2F0KGxvY2F0aW9uWzFdKSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhsb2NhdGlvbilcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBpZiAoIWxpc3RMb25naXR1ZGUuaW5jbHVkZXMoZGF0YS5sb25naXR1ZGUpKXtcbiAgICAgICAgICAgICAgICAvLyAgICAgbGlzdENpdGllcy5wdXNoKGRhdGEuY2l0eSlcbiAgICAgICAgICAgICAgICAvLyAgICAgbGlzdExvbmdpdHVkZS5wdXNoKGRhdGEubG9uZ2l0dWRlKVxuICAgICAgICAgICAgICAgIC8vICAgICBsaXN0TGF0aXR1ZGUucHVzaChkYXRhLmxhdGl0dWRlKVxuICAgICAgICAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhpcF9jb2xsZWN0aW9uKVxuICAgICAgICAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhsaXN0Q2l0aWVzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIGxpc3RDaXRpZXMubGVuZ3RoID09PSBpcF9jb2xsZWN0aW9uLmxlbmd0aCApe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Bpbm5lci5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25EZXRhaWxzLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWNib29rLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbkgxLmlubmVySFRNTCA9IGBZb3UndmUgYXJyaXZlIGF0ICR7bGlzdENpdGllc1swXX1gXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlTWFwKClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIC8vIH0saSAqIDE1MDApXG4gICAgfVxufSBcblxuLy8gd2luZG93LmxvY2F0ZURldGFpbHMgPSBsb2NhdGVEZXRhaWxzXG5cblxuXG5cbi8vTWFrZXMgYSBtYXAgYXMgYW4gaW5zdGFuY2Ugb2YgTWFwXG4vL1Rha2VzIGluIHRoZSBmaXJzdCBwb3NpdGlvbnMgZnJvbSBsaXN0TGF0aXR1ZGUgYW5kIGxpc3RMb25naXR1ZGVcbi8vQ3JlYXRlIGEgbmV3IHNjcmlwdCBIVE1MIGVsZW1lbnRcbi8vRmV0Y2hlcyB0aGUgZ29vZ2xlIG1hcHMgQVBJIGtleSBmcm9tIHRoZSBwcm94eSBzZXJ2ZXJcbi8vU2V0cyB0aGUgbmV3IHNjcmlwdCBzcmMgdG8gZXF1YWwgb3VyIGdvb2dsZSBtYXBzIEFQSSBjYWxsXG4vL0dvb2dsZSBtYXBzIEFQSSByZXF1aXJlcyBhIGNhbGxiYWNrIGZ1bmN0aW9uLCBoZW5jZSBtYXAuaW5pdE1hcFxubGV0IG1hcDtcbmZ1bmN0aW9uIG1ha2VNYXAoKXtcbiAgICBtYXAgPSBuZXcgTWFwKGxpc3RMYXRpdHVkZVswXSwgbGlzdExvbmdpdHVkZVswXSlcbiAgICBtYXAuaW5pdE1hcFxuICAgIGxldCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKVxuICAgIC8vc2V0dGluZyBzcmMgaHRtbCB0YWcgZXF1YWwgdG8gbXkgZ29vZ2xlIEFQSSBDYWxsXG4gICAgLy8gZmV0Y2goXCJodHRwczovL21hcHBpbmctdGhlLW1hdHJpeC5vbnJlbmRlci5jb20vZ29vZ1wiKS50aGVuKHJlcyA9PiB7XG4gICAgZmV0Y2goXCJodHRwOi8vbG9jYWxob3N0OjUwMDEvZ29vZ1wiKS50aGVuKHJlcyA9PiB7XG4gICAgICAgIHJldHVybiByZXMudGV4dCgpXG4gICAgfSkudGhlbihrZXkgPT4ge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhrZXkpXG4gICAgICAgIHNjcmlwdC5zcmMgPSBgaHR0cHM6Ly9tYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL2pzP2tleT0ke2tleX0mY2FsbGJhY2s9bWFwLmluaXRNYXBgXG4gICAgfSlcbiAgICAvL3NldHRpbmcgYXN5bmMgdHJ1ZSBvbiBvdXIgSFRNTCBlbGVtZW50XG4gICAgc2NyaXB0LmFzeW5jID0gdHJ1ZVxuICAgIC8vYWRkaW5nIGh0bWwgZWxlbWVudCB0byBvdXIgaGVhZCBzZWN0aW9uIG9mIG91ciBIVE1MIGRvY3VtZW50XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpXG4gICAgLy9zZXR0aW5nIG1hcCBvbiB0aGUgd2luZG93XG4gICAgd2luZG93Lm1hcCA9IG1hcFxufVxuXG5cblxuLy9MaXN0ZW5zIGZvciBuZXh0LWJ1dHRvbiBjbGlja1xuLy9PbiBidXR0b24gY2xpY2sgaW5jcmVtZW50IGkgYnkgMVxuLy9TZXQgdGhlIGFycml2ZWQgZGVzdGluYXRpb24gdG8gdGhlIHVwZGF0ZWQgY2l0eVxuLy91cGRhdGUgdGhlIG1hcCBhbmQgbWFya2VyIHRvIHVwZGF0ZWQgY29vcmRpbmF0ZXNcbi8vaWYgd2UndmUgcmVhY2hlZCB0aGUgZW5kIHdlIHByb3ZpZGUgc3VtbWFyeSB2aWV3IG9mIGFsbCBtYXBwZWQgbG9jYXRpb25cbmxldCBpID0gMFxubGV0IGRlc3RpbmF0aW9uSDEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRlc3RpbmF0aW9uXCIpXG5kZXN0aW5hdGlvbkgxLmlubmVySFRNTCA9IGBZb3UndmUgYXJyaXZlZCBhdCAke2xpc3RDaXRpZXNbaV19YFxuY29uc3QgbmV4dEJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibmV4dC1idXR0b25cIilcbmNvbnN0IG9uTmV4dENsaWNrID0gZnVuY3Rpb24oZXZlbnQpe1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaSArPTE7XG4gICAgZGVzdGluYXRpb25IMS5pbm5lckhUTUwgPSBgWW91J3ZlIGFycml2ZWQgYXQgJHtsaXN0Q2l0aWVzW2ldfWBcbiAgICBtYXAudXBkYXRlTWFwQW5kTWFya2VyUG9zaXRpb24obGlzdExhdGl0dWRlW2ldLCBsaXN0TG9uZ2l0dWRlW2ldKVxuICAgIGlmICggaSA9PT0gbGlzdExhdGl0dWRlLmxlbmd0aCl7XG4gICAgICAgIGRlc3RpbmF0aW9uSDEuaW5uZXJIVE1MID0gXCJZb3VyIE1hcHBlZCBNYXRyaXhcIlxuICAgICAgICBtYXAuYWRkTWFya2VycyhsaXN0TGF0aXR1ZGUsIGxpc3RMb25naXR1ZGUpXG4gICAgICAgIG5leHRCdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbk5leHRDbGljaylcbiAgICB9XG59XG5uZXh0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25OZXh0Q2xpY2spXG5cblxuLy9zZXQgY2FudmFzIHRvIHRvIEhUTUwgY2FudmFzIGVsZW1lbnRcbmNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2FudmFzXCIpO1xuY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbi8vc2V0IGNhbnZhcyB0byB0aGUgY3VycmVudCB3aW5kb3cgd2lkdGggYW5kIGhlaWdodFxuY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG5jYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuLy9jb2xvciBhbmQgZm9udCBzdHlsZVxuY3R4LmZpbGxTdHlsZSA9IFwiIzBGMFwiO1xuY3R4LmZvbnQgPSBcIjE2cHggbW9ub3NwYWNlXCI7XG5cblxuXG5jb25zdCBjaGFycyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVowMTIzNDU2Nzg5XCI7XG5jb25zdCBjaGFyQXJyID0gY2hhcnMuc3BsaXQoXCJcIik7XG4vL251bWJlciBvZiBjb2x1bW5zIG5lZWRlZCBiYXNlZCBvbiB0aGUgd2lkdGggb2YgdGhlIHdpbmRvd1xuY29uc3QgY29sdW1ucyA9IGNhbnZhcy53aWR0aCAvIDE2O1xubGV0IGRyb3BzID0gW107XG4vL3NldCBlYWNoIGVsZW1lbnQgaW4gY29sdW1uIGVxdWFsIHRvIDFcbmZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uczsgaSsrKSB7XG4gICAgZHJvcHNbaV0gPSAxO1xufVxuXG5cbmZ1bmN0aW9uIGRyYXcoKSB7XG4gICAgLy9zZXQgY2FudmFzIHRvIHNlbWktdHJhbnNwYXJlbnQgYmxhY2tcbiAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2JhKDAsIDAsIDAsIDAuMDUpXCI7XG4gICAgLy9kcmF3cyByZWN0YW5nbGUgYmFzZWQgb24gY2FudmFzIHdpZHRoIGFuZCBoZWlnaCB0aGF0IHdlIHNldCBlYXJsaWVyXG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgLy9zZXQgZmlsbHN0eWxlIHRvIGdyZWVuXG4gICAgY3R4LmZpbGxTdHlsZSA9IFwiIzBGMFwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy9zZXRzIGNoYXIgaW5kZXggdG8gaG9sZCBhIHJhbmRvbSBpbmRleCB1cCB0byB0aGUgY2hhciBBcnJheSBsZW5ndGhcbiAgICAgICAgY29uc3QgY2hhckluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhckFyci5sZW5ndGgpO1xuICAgICAgICAvL3NldCBjaGFyIHRvIHRoZSByYW5kb20gY2hhclxuICAgICAgICBjb25zdCBjaGFyID0gY2hhckFycltjaGFySW5kZXhdO1xuICAgICAgICAvL2ZpbGxzIHRleHRcbiAgICAgICAgY3R4LmZpbGxUZXh0KGNoYXIsIGkgKiAxNiwgZHJvcHNbaV0gKiAxNik7XG4gICAgICAgIC8vcmVzZXRzIGRyb3AgYmFjayB0byAwLCBvdGhlcndpc2UgaW5jcmVtZW50XG4gICAgICAgIGlmIChkcm9wc1tpXSAqIDE2ID4gY2FudmFzLmhlaWdodCAmJiBNYXRoLnJhbmRvbSgpID4gMC45NSkge1xuICAgICAgICAgICAgZHJvcHNbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGRyb3BzW2ldKys7XG4gICAgfVxufVxuXG4vL3Jlc2l6ZXMgdGhlIGNhbnZhcyBiYXNlZCBvbiB0aGUgc3RhdGUgb2YgdGhlIHdpbmRvdyBhbmQgaGVpZ2h0XG5mdW5jdGlvbiByZXNpemVDYW52YXMoKXtcbiAgICBjYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aFxuICAgIGNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICBjb25zdCBjb2x1bW5zID0gY2FudmFzLndpZHRoIC8gMTZcbiAgICBkcm9wcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uczsgaSsrKSB7XG4gICAgICAgIGRyb3BzW2ldID0gMVxuICAgIH1cbn1cblxuLy9saXN0ZW5pbmcgZm9yIHdpbmRvdyByZXNpemUsIHJ1bnMgY2FsbGJhY2sgaWYgaXQgZG9lc1xud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2l6ZUNhbnZhcylcbnJlc2l6ZUNhbnZhcygpO1xuXG5cbmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKGV2ZW50KXtcblxuICAgIGNvbnN0IG1vdXNlWCA9IGV2ZW50LmNsaWVudFggLSBjYW52YXMub2Zmc2V0TGVmdDtcbiAgICBjb25zdCBtb3VzZVkgPSBldmVudC5jbGllbnRZIC0gY2FudmFzLm9mZnNldFRvcDtcblxuICAgIGNvbnN0IGNvbHVtbiA9IE1hdGguZmxvb3IobW91c2VYIC8gMTYpO1xuICAgIGNvbnN0IHJvdyA9IE1hdGguZmxvb3IobW91c2VZIC8gMTYpO1xuXG4gICAgY3R4LmZpbGxTdHlsZSA9IFwiI2ZmMzMzM1wiO1xuICAgIGZvciAobGV0IGkgPSBjb2x1bW4gLSAxOyBpIDw9IGNvbHVtbiArIDE7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gcm93IC0gMTsgaiA8PSByb3cgKyAxOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChpID49IDAgJiYgaSA8IGNvbHVtbnMgJiYgaiA+PSAwICYmIGogPCBkcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoY2hhckFycltNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyQXJyLmxlbmd0aCldLCBpICogMTYsIGRyb3BzW2pdICogMTYpO1xuICAgICAgICAgICAgfSAgXG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuXG4vL2RyYXdzIGNhbnZhcyBldmVyeSAzMyBtaWxpc2Vjb25kc1xuc2V0SW50ZXJ2YWwoZHJhdywgMzMpOyJdLCJuYW1lcyI6WyJUcmFjZXJvdXRlIiwiTG9jYXRpb24iLCJNYXAiLCJhc3luYyIsImdldFN0YXJ0ZWQiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwibWFjYm9vayIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsInByZXZlbnREZWZhdWx0Iiwid2VsY29tZVBhZ2UiLCJlbnRlckRlc3RpbmF0aW9uIiwiY2xhc3NMaXN0IiwiYWRkIiwicmVtb3ZlIiwibGV0c0dvIiwic3Bpbm5lciIsImRvbWFpbklucHV0IiwidmFsdWUiLCJhbGVydCIsInJvdXRlcyIsInRyYWNlUm91dGUiLCJpcFRlc3QiLCJpcF9jb2xsZWN0aW9uIiwiaGFzQWxwaGFDaGFyYWN0ZXJzIiwiaXAiLCJtYXRjaCIsInZhbGlkSVAiLCJkb21haW4iLCJyb3V0ZSIsImdldFJvdXRlIiwidGhlbiIsImRhdGEiLCJudW1iZXIiLCJyZXNwb25zZSIsImhvcHMiLCJwdXNoIiwibG9jYXRlRGV0YWlscyIsImxvY2F0ZSIsImxpc3RDaXRpZXMiLCJsaXN0TG9uZ2l0dWRlIiwibGlzdExhdGl0dWRlIiwiZGVzdGluYXRpb25EZXRhaWxzIiwiaSIsImxlbmd0aCIsImdlb2xvY2F0aW9uIiwiZ2V0TG9jYXRpb24iLCJjb25zb2xlIiwibG9nIiwibG9jIiwibG9jYXRpb24iLCJzcGxpdCIsImNpdHkiLCJwYXJzZUZsb2F0IiwiZGVzdGluYXRpb25IMSIsImlubmVySFRNTCIsIm1ha2VNYXAiLCJtYXAiLCJpbml0TWFwIiwic2NyaXB0IiwiY3JlYXRlRWxlbWVudCIsImZldGNoIiwicmVzIiwidGV4dCIsImtleSIsInNyYyIsImhlYWQiLCJhcHBlbmRDaGlsZCIsIndpbmRvdyIsIm5leHRCdXR0b24iLCJvbk5leHRDbGljayIsInVwZGF0ZU1hcEFuZE1hcmtlclBvc2l0aW9uIiwiYWRkTWFya2VycyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjYW52YXMiLCJjdHgiLCJnZXRDb250ZXh0Iiwid2lkdGgiLCJpbm5lcldpZHRoIiwiaGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJmaWxsU3R5bGUiLCJmb250IiwiY2hhcnMiLCJjaGFyQXJyIiwiY29sdW1ucyIsImRyb3BzIiwiZHJhdyIsImZpbGxSZWN0IiwiY2hhckluZGV4IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwiY2hhciIsImZpbGxUZXh0IiwicmVzaXplQ2FudmFzIiwibW91c2VYIiwiY2xpZW50WCIsIm9mZnNldExlZnQiLCJtb3VzZVkiLCJjbGllbnRZIiwib2Zmc2V0VG9wIiwiY29sdW1uIiwicm93IiwiaiIsInNldEludGVydmFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/location.js":
/*!*************************!*\
  !*** ./src/location.js ***!
  \*************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nclass Location {\n  constructor() {}\n  async getLocation(ip) {\n    //api call to gather geolocation info\n    // const location = await fetch(`https://mapping-the-matrix.onrender.com/location?ip=${ip}`)\n    const location = await fetch(`http://localhost:5001/location?ip=${ip}`);\n    const data = await location.json();\n    return data;\n  }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (Location);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbG9jYXRpb24uanMuanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU1BLFFBQVE7RUFDVkMsV0FBV0EsQ0FBQSxFQUFFLENBRWI7RUFDQSxNQUFNQyxXQUFXQSxDQUFDQyxFQUFFLEVBQUM7SUFDakI7SUFDQTtJQUNBLE1BQU1DLFFBQVEsR0FBRyxNQUFNQyxLQUFLLENBQUUscUNBQW9DRixFQUFHLEVBQUMsQ0FBQztJQUN2RSxNQUFNRyxJQUFJLEdBQUcsTUFBTUYsUUFBUSxDQUFDRyxJQUFJLEVBQUU7SUFDbEMsT0FBT0QsSUFBSTtFQUNmO0FBQ0o7QUFFQSwrREFBZU4sUUFBUSIsInNvdXJjZXMiOlsid2VicGFjazovL21hcF9tYXRyaXgvLi9zcmMvbG9jYXRpb24uanM/MDhhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBMb2NhdGlvbntcbiAgICBjb25zdHJ1Y3Rvcigpe1xuXG4gICAgfVxuICAgIGFzeW5jIGdldExvY2F0aW9uKGlwKXtcbiAgICAgICAgLy9hcGkgY2FsbCB0byBnYXRoZXIgZ2VvbG9jYXRpb24gaW5mb1xuICAgICAgICAvLyBjb25zdCBsb2NhdGlvbiA9IGF3YWl0IGZldGNoKGBodHRwczovL21hcHBpbmctdGhlLW1hdHJpeC5vbnJlbmRlci5jb20vbG9jYXRpb24/aXA9JHtpcH1gKVxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGF3YWl0IGZldGNoKGBodHRwOi8vbG9jYWxob3N0OjUwMDEvbG9jYXRpb24/aXA9JHtpcH1gKVxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgbG9jYXRpb24uanNvbigpXG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMb2NhdGlvbiJdLCJuYW1lcyI6WyJMb2NhdGlvbiIsImNvbnN0cnVjdG9yIiwiZ2V0TG9jYXRpb24iLCJpcCIsImxvY2F0aW9uIiwiZmV0Y2giLCJkYXRhIiwianNvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/location.js\n");

/***/ }),

/***/ "./src/maps.js":
/*!*********************!*\
  !*** ./src/maps.js ***!
  \*********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nclass Map {\n  constructor(latitude, longitude) {\n    _defineProperty(this, \"initMap\", function () {\n      const options = {\n        zoom: 11,\n        center: {\n          lat: this.latitude,\n          lng: this.longitude\n        }\n      };\n      this.map = new google.maps.Map(document.getElementById('map'), options);\n      this.markers.push(new google.maps.Marker({\n        position: {\n          lat: this.latitude,\n          lng: this.longitude\n        },\n        map: this.map,\n        animation: google.maps.Animation.DROP\n      }));\n    });\n    _defineProperty(this, \"updateMapAndMarkerPosition\", function (lat, long) {\n      if (!isNaN(lat) && !isNaN(long)) {\n        let newCenter = new google.maps.LatLng(lat, long);\n        this.map.setCenter(newCenter);\n        this.markers[0].setPosition(newCenter);\n      }\n    });\n    _defineProperty(this, \"addMarkers\", function (lat, long) {\n      this.markers.forEach(marker => marker.setMap(null));\n      this.markers = [];\n      const bounds = new google.maps.LatLngBounds();\n      for (let i = 0; i < lat.length; i++) {\n        const marker = new google.maps.Marker({\n          position: {\n            lat: lat[i],\n            lng: long[i]\n          },\n          map: this.map,\n          label: (i + 1).toString()\n        });\n        this.markers.push(marker);\n        bounds.extend(marker.getPosition());\n      }\n      this.map.fitBounds(bounds);\n    });\n    this.map = null;\n    this.longitude = longitude;\n    this.latitude = latitude;\n    this.markers = [];\n  }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (Map);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWFwcy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsR0FBRztFQUNQQyxXQUFXQSxDQUFDQyxRQUFRLEVBQUVDLFNBQVMsRUFBRTtJQUFBQyxlQUFBLGtCQU92QixZQUFXO01BQ25CLE1BQU1DLE9BQU8sR0FBRztRQUNaQyxJQUFJLEVBQUUsRUFBRTtRQUNSQyxNQUFNLEVBQUU7VUFBRUMsR0FBRyxFQUFFLElBQUksQ0FBQ04sUUFBUTtVQUFFTyxHQUFHLEVBQUUsSUFBSSxDQUFDTjtRQUFVO01BQ3RELENBQUM7TUFDRCxJQUFJLENBQUNPLEdBQUcsR0FBRyxJQUFJQyxNQUFNLENBQUNDLElBQUksQ0FBQ1osR0FBRyxDQUFDYSxRQUFRLENBQUNDLGNBQWMsQ0FBQyxLQUFLLENBQUMsRUFBRVQsT0FBTyxDQUFDO01BQ3ZFLElBQUksQ0FBQ1UsT0FBTyxDQUFDQyxJQUFJLENBQUMsSUFBSUwsTUFBTSxDQUFDQyxJQUFJLENBQUNLLE1BQU0sQ0FBQztRQUNyQ0MsUUFBUSxFQUFFO1VBQUVWLEdBQUcsRUFBRSxJQUFJLENBQUNOLFFBQVE7VUFBRU8sR0FBRyxFQUFFLElBQUksQ0FBQ047UUFBVSxDQUFDO1FBQ3JETyxHQUFHLEVBQUUsSUFBSSxDQUFDQSxHQUFHO1FBQ2JTLFNBQVMsRUFBRVIsTUFBTSxDQUFDQyxJQUFJLENBQUNRLFNBQVMsQ0FBQ0M7TUFDbkMsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBQUFqQixlQUFBLHFDQUM0QixVQUFTSSxHQUFHLEVBQUVjLElBQUksRUFBRTtNQUMvQyxJQUFJLENBQUNDLEtBQUssQ0FBQ2YsR0FBRyxDQUFDLElBQUksQ0FBQ2UsS0FBSyxDQUFDRCxJQUFJLENBQUMsRUFBRTtRQUMvQixJQUFJRSxTQUFTLEdBQUcsSUFBSWIsTUFBTSxDQUFDQyxJQUFJLENBQUNhLE1BQU0sQ0FBQ2pCLEdBQUcsRUFBRWMsSUFBSSxDQUFDO1FBQ2pELElBQUksQ0FBQ1osR0FBRyxDQUFDZ0IsU0FBUyxDQUFDRixTQUFTLENBQUM7UUFDN0IsSUFBSSxDQUFDVCxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUNZLFdBQVcsQ0FBQ0gsU0FBUyxDQUFDO01BQ3hDO0lBQ0YsQ0FBQztJQUFBcEIsZUFBQSxxQkFDWSxVQUFTSSxHQUFHLEVBQUVjLElBQUksRUFBQztNQUM5QixJQUFJLENBQUNQLE9BQU8sQ0FBQ2EsT0FBTyxDQUFDQyxNQUFNLElBQUlBLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO01BQ25ELElBQUksQ0FBQ2YsT0FBTyxHQUFHLEVBQUU7TUFDakIsTUFBTWdCLE1BQU0sR0FBRyxJQUFJcEIsTUFBTSxDQUFDQyxJQUFJLENBQUNvQixZQUFZLEVBQUU7TUFDN0MsS0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUd6QixHQUFHLENBQUMwQixNQUFNLEVBQUVELENBQUMsRUFBRSxFQUFDO1FBQ2xDLE1BQU1KLE1BQU0sR0FBRyxJQUFJbEIsTUFBTSxDQUFDQyxJQUFJLENBQUNLLE1BQU0sQ0FBQztVQUNwQ0MsUUFBUSxFQUFFO1lBQUVWLEdBQUcsRUFBRUEsR0FBRyxDQUFDeUIsQ0FBQyxDQUFDO1lBQUV4QixHQUFHLEVBQUVhLElBQUksQ0FBQ1csQ0FBQztVQUFFLENBQUM7VUFDdkN2QixHQUFHLEVBQUUsSUFBSSxDQUFDQSxHQUFHO1VBQ2J5QixLQUFLLEVBQUUsQ0FBQ0YsQ0FBQyxHQUFHLENBQUMsRUFBRUcsUUFBUTtRQUN6QixDQUFDLENBQUM7UUFDRixJQUFJLENBQUNyQixPQUFPLENBQUNDLElBQUksQ0FBQ2EsTUFBTSxDQUFDO1FBQ3pCRSxNQUFNLENBQUNNLE1BQU0sQ0FBQ1IsTUFBTSxDQUFDUyxXQUFXLEVBQUUsQ0FBQztNQUNyQztNQUNBLElBQUksQ0FBQzVCLEdBQUcsQ0FBQzZCLFNBQVMsQ0FBQ1IsTUFBTSxDQUFDO0lBQzVCLENBQUM7SUF2Q0MsSUFBSSxDQUFDckIsR0FBRyxHQUFHLElBQUk7SUFDZixJQUFJLENBQUNQLFNBQVMsR0FBR0EsU0FBUztJQUMxQixJQUFJLENBQUNELFFBQVEsR0FBR0EsUUFBUTtJQUN4QixJQUFJLENBQUNhLE9BQU8sR0FBRyxFQUFFO0VBQ3JCO0FBb0NGO0FBRUEsK0RBQWVmLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXBfbWF0cml4Ly4vc3JjL21hcHMuanM/NTBiNyJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBNYXB7XG4gIGNvbnN0cnVjdG9yKGxhdGl0dWRlLCBsb25naXR1ZGUpIHtcbiAgICAgIHRoaXMubWFwID0gbnVsbDtcbiAgICAgIHRoaXMubG9uZ2l0dWRlID0gbG9uZ2l0dWRlXG4gICAgICB0aGlzLmxhdGl0dWRlID0gbGF0aXR1ZGVcbiAgICAgIHRoaXMubWFya2VycyA9IFtdO1xuICB9XG5cbiAgaW5pdE1hcCA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7ICAgICBcbiAgICAgICAgem9vbTogMTEsXG4gICAgICAgIGNlbnRlcjogeyBsYXQ6IHRoaXMubGF0aXR1ZGUsIGxuZzogdGhpcy5sb25naXR1ZGUgfVxuICAgIH1cbiAgICB0aGlzLm1hcCA9IG5ldyBnb29nbGUubWFwcy5NYXAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21hcCcpLCBvcHRpb25zKVxuICAgIHRoaXMubWFya2Vycy5wdXNoKG5ldyBnb29nbGUubWFwcy5NYXJrZXIoe1xuICAgICAgICBwb3NpdGlvbjogeyBsYXQ6IHRoaXMubGF0aXR1ZGUsIGxuZzogdGhpcy5sb25naXR1ZGUgfSxcbiAgICAgICAgbWFwOiB0aGlzLm1hcCxcbiAgICAgICAgYW5pbWF0aW9uOiBnb29nbGUubWFwcy5BbmltYXRpb24uRFJPUFxuICAgICAgfSkpO1xuICAgIH07XG4gICAgdXBkYXRlTWFwQW5kTWFya2VyUG9zaXRpb24gPSBmdW5jdGlvbihsYXQsIGxvbmcpIHtcbiAgICAgIGlmICghaXNOYU4obGF0KSAmJiAhaXNOYU4obG9uZykpIHtcbiAgICAgICAgbGV0IG5ld0NlbnRlciA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmcobGF0LCBsb25nKTtcbiAgICAgICAgdGhpcy5tYXAuc2V0Q2VudGVyKG5ld0NlbnRlcik7XG4gICAgICAgIHRoaXMubWFya2Vyc1swXS5zZXRQb3NpdGlvbihuZXdDZW50ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBhZGRNYXJrZXJzID0gZnVuY3Rpb24obGF0LCBsb25nKXtcbiAgICAgIHRoaXMubWFya2Vycy5mb3JFYWNoKG1hcmtlciA9PiBtYXJrZXIuc2V0TWFwKG51bGwpKVxuICAgICAgdGhpcy5tYXJrZXJzID0gW11cbiAgICAgIGNvbnN0IGJvdW5kcyA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHMoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGF0Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgY29uc3QgbWFya2VyID0gbmV3IGdvb2dsZS5tYXBzLk1hcmtlcih7XG4gICAgICAgICAgcG9zaXRpb246IHsgbGF0OiBsYXRbaV0sIGxuZzogbG9uZ1tpXSB9LFxuICAgICAgICAgIG1hcDogdGhpcy5tYXAsXG4gICAgICAgICAgbGFiZWw6IChpICsgMSkudG9TdHJpbmcoKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXJrZXJzLnB1c2gobWFya2VyKVxuICAgICAgICBib3VuZHMuZXh0ZW5kKG1hcmtlci5nZXRQb3NpdGlvbigpKVxuICAgICAgfVxuICAgICAgdGhpcy5tYXAuZml0Qm91bmRzKGJvdW5kcylcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hcCJdLCJuYW1lcyI6WyJNYXAiLCJjb25zdHJ1Y3RvciIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiX2RlZmluZVByb3BlcnR5Iiwib3B0aW9ucyIsInpvb20iLCJjZW50ZXIiLCJsYXQiLCJsbmciLCJtYXAiLCJnb29nbGUiLCJtYXBzIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsIm1hcmtlcnMiLCJwdXNoIiwiTWFya2VyIiwicG9zaXRpb24iLCJhbmltYXRpb24iLCJBbmltYXRpb24iLCJEUk9QIiwibG9uZyIsImlzTmFOIiwibmV3Q2VudGVyIiwiTGF0TG5nIiwic2V0Q2VudGVyIiwic2V0UG9zaXRpb24iLCJmb3JFYWNoIiwibWFya2VyIiwic2V0TWFwIiwiYm91bmRzIiwiTGF0TG5nQm91bmRzIiwiaSIsImxlbmd0aCIsImxhYmVsIiwidG9TdHJpbmciLCJleHRlbmQiLCJnZXRQb3NpdGlvbiIsImZpdEJvdW5kcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/maps.js\n");

/***/ }),

/***/ "./src/traceroute.js":
/*!***************************!*\
  !*** ./src/traceroute.js ***!
  \***************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nclass Traceroute {\n  constructor() {}\n  async getRoute(name) {\n    const route = await fetch(`http://localhost:5001/traceroute?domain=${name}`);\n    // const route = await fetch(`https://mapping-the-matrix.onrender.com/?domain=${name}`)\n    const data = await route.json();\n    console.log(data);\n    return data;\n  }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (Traceroute);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdHJhY2Vyb3V0ZS5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsVUFBVSxDQUFDO0VBQ2JDLFdBQVdBLENBQUEsRUFBRSxDQUViO0VBQ0EsTUFBTUMsUUFBUUEsQ0FBQ0MsSUFBSSxFQUFDO0lBQ2hCLE1BQU1DLEtBQUssR0FBRyxNQUFNQyxLQUFLLENBQUUsMkNBQTBDRixJQUFLLEVBQUMsQ0FBQztJQUM1RTtJQUNBLE1BQU1HLElBQUksR0FBRyxNQUFNRixLQUFLLENBQUNHLElBQUksRUFBRTtJQUMvQkMsT0FBTyxDQUFDQyxHQUFHLENBQUNILElBQUksQ0FBQztJQUNqQixPQUFPQSxJQUFJO0VBQ2Y7QUFDSjtBQUVBLCtEQUFlTixVQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFwX21hdHJpeC8uL3NyYy90cmFjZXJvdXRlLmpzPzkzNzAiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgVHJhY2Vyb3V0ZSB7XG4gICAgY29uc3RydWN0b3IoKXtcblxuICAgIH1cbiAgICBhc3luYyBnZXRSb3V0ZShuYW1lKXtcbiAgICAgICAgY29uc3Qgcm91dGUgPSBhd2FpdCBmZXRjaChgaHR0cDovL2xvY2FsaG9zdDo1MDAxL3RyYWNlcm91dGU/ZG9tYWluPSR7bmFtZX1gKVxuICAgICAgICAvLyBjb25zdCByb3V0ZSA9IGF3YWl0IGZldGNoKGBodHRwczovL21hcHBpbmctdGhlLW1hdHJpeC5vbnJlbmRlci5jb20vP2RvbWFpbj0ke25hbWV9YClcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJvdXRlLmpzb24oKTtcbiAgICAgICAgY29uc29sZS5sb2coZGF0YSlcbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRyYWNlcm91dGUiXSwibmFtZXMiOlsiVHJhY2Vyb3V0ZSIsImNvbnN0cnVjdG9yIiwiZ2V0Um91dGUiLCJuYW1lIiwicm91dGUiLCJmZXRjaCIsImRhdGEiLCJqc29uIiwiY29uc29sZSIsImxvZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/traceroute.js\n");

/***/ }),

/***/ "./src/index.css":
/*!***********************!*\
  !*** ./src/index.css ***!
  \***********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguY3NzLmpzIiwibWFwcGluZ3MiOiI7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL21hcF9tYXRyaXgvLi9zcmMvaW5kZXguY3NzPzgwNmUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.css\n");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ (function(module) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; };\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) });\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: true });\n  defineProperty(\n    GeneratorFunctionPrototype,\n    \"constructor\",\n    { value: GeneratorFunction, configurable: true }\n  );\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    defineProperty(this, \"_invoke\", { value: enqueue });\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var methodName = context.method;\n    var method = delegate.iterator[methodName];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method, or a missing .next mehtod, always terminate the\n      // yield* loop.\n      context.delegate = null;\n\n      // Note: [\"return\"] must be used for ES3 parsing compatibility.\n      if (methodName === \"throw\" && delegate.iterator[\"return\"]) {\n        // If the delegate iterator has a return method, give it a\n        // chance to clean up.\n        context.method = \"return\";\n        context.arg = undefined;\n        maybeInvokeDelegate(delegate, context);\n\n        if (context.method === \"throw\") {\n          // If maybeInvokeDelegate(context) changed context.method from\n          // \"return\" to \"throw\", let that override the TypeError below.\n          return ContinueSentinel;\n        }\n      }\n      if (methodName !== \"return\") {\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a '\" + methodName + \"' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(val) {\n    var object = Object(val);\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n   true ? module.exports : 0\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLGlEQUFpRDs7QUFFNUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ04sZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx1REFBdUQ7QUFDN0Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxnQkFBZ0I7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxtQkFBbUI7QUFDcEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsS0FBMEIsb0JBQW9CLENBQUU7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFwX21hdHJpeC8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanM/OTZjZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGZ1bmN0aW9uIChvYmosIGtleSwgZGVzYykgeyBvYmpba2V5XSA9IGRlc2MudmFsdWU7IH07XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuICB0cnkge1xuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGRlZmluZVByb3BlcnR5KGdlbmVyYXRvciwgXCJfaW52b2tlXCIsIHsgdmFsdWU6IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkgfSk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgZGVmaW5lUHJvcGVydHkoR3AsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgZGVmaW5lUHJvcGVydHkoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgXCJjb25zdHJ1Y3RvclwiLFxuICAgIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uLCBjb25maWd1cmFibGU6IHRydWUgfVxuICApO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShcbiAgICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSxcbiAgICB0b1N0cmluZ1RhZ1N5bWJvbCxcbiAgICBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgKTtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaW52b2tlXCIsIHsgdmFsdWU6IGVucXVldWUgfSk7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLFxuICAgICAgUHJvbWlzZUltcGxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kTmFtZSA9IGNvbnRleHQubWV0aG9kO1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2ROYW1lXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kLCBvciBhIG1pc3NpbmcgLm5leHQgbWVodG9kLCBhbHdheXMgdGVybWluYXRlIHRoZVxuICAgICAgLy8geWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgIGlmIChtZXRob2ROYW1lID09PSBcInRocm93XCIgJiYgZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1ldGhvZE5hbWUgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ1wiICsgbWV0aG9kTmFtZSArIFwiJyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9KTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHZhciBvYmplY3QgPSBPYmplY3QodmFsKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgaW4gbW9kZXJuIGVuZ2luZXNcbiAgLy8gd2UgY2FuIGV4cGxpY2l0bHkgYWNjZXNzIGdsb2JhbFRoaXMuIEluIG9sZGVyIGVuZ2luZXMgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiKSB7XG4gICAgZ2xvYmFsVGhpcy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xuICB9IGVsc2Uge1xuICAgIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	__webpack_require__("./src/index.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.css");
/******/ 	
/******/ })()
;