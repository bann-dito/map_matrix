/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _traceroute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./traceroute */ \"./src/traceroute.js\");\n/* harmony import */ var _location__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./location */ \"./src/location.js\");\n/* harmony import */ var _maps__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./maps */ \"./src/maps.js\");\n/* harmony import */ var regenerator_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n/* harmony import */ var regenerator_runtime__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\n//Sets getStarted to the get-started HTML elements\nconst getStarted = document.getElementById(\"get-started\");\nconst macbook = document.getElementById(\"macbook-container\");\n\n//Listens for a click on the get-started button\n//To summ. this hides the homepage and shows the enter destination container\ngetStarted.addEventListener('click', event => {\n  //prevents the default of loading a page on click\n  event.preventDefault();\n  //saves the HTML container welcome container\n  const welcomePage = document.getElementById(\"welcome-container\");\n  //saves the HTNL container destinations\n  const enterDestination = document.getElementById(\"enter-destination\");\n  //Adds hidden to the HTML container \n  welcomePage.classList.add('hidden');\n  //Rmoeves hidden from the HTML container destination\n  enterDestination.classList.remove('hidden');\n  //Removes hidden from the HTML container macbook-container\n  macbook.classList.remove('hidden');\n});\nconst letsGo = document.getElementById(\"domain-submit\");\n\n//Summarize, this function waits for this for lets go to be clicked\n//Hides HTML elements, shows the destinations details container\n//Gathers user input and passes it to routes function\nconst spinner = document.getElementById(\"spinner\");\nletsGo.addEventListener('click', event => {\n  const domainInput = document.getElementById(\"domain\").value;\n  if (domainInput === \"\") {\n    alert(\"Please enter a domain name, i.e. google.com, facebook.com, twitter.com, etc.\");\n    return;\n  }\n  event.preventDefault();\n  const enterDestination = document.getElementById(\"enter-destination\");\n  // const destinationDetails = document.getElementById(\"destination-details\")\n  enterDestination.classList.add('hidden');\n  macbook.classList.add('hidden');\n  spinner.classList.remove('hidden');\n  // destinationDetails.classList.remove('hidden')\n  // domainInput = document.getElementById(\"domain\").value\n\n  // console.log(domainInput)\n  routes(domainInput);\n});\n\n// window.domainInput = domainInput\n\n//makes a new traceroute instance\nconst traceRoute = new _traceroute__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n//array of collected IP from the routes function\nlet ipTest = ['0.0.0.0', '0.0.0.0', 'ae2.3612.edge6.Washington12.level3.net', '4.68.38.6', '129.134.99.222', '173.252.67.63'];\nlet ip_collection = [];\nconst hasAlphaCharacters = function (ip) {\n  if (ip.match(/[a-z]/i)) {\n    return true;\n  }\n};\nconst validIP = function (ip) {\n  if (ip === \"0.0.0.0\" || ip === \"*\") {\n    return false;\n  } else if (hasAlphaCharacters(ip)) {\n    return false;\n  } else {\n    return true;\n  }\n};\n\n//Summarize, takes domain input from the Lets go event listener\n//calls the class function getRoute and passes the domain input\n//get route is an API fetch and passes each hop into \n//calls the locate details function when done\nconst routes = function (domain) {\n  const route = traceRoute.getRoute(domain);\n  route.then(data => {\n    // console.log(data.response.hops, \"hops console log\")\n    for (let number in data.response.hops) {\n      if (validIP(data.response.hops[number].ip)) {\n        ip_collection.push(data.response.hops[number].ip);\n      }\n    }\n    locateDetails();\n  });\n};\n\n// const routes = function(domain){\n//     for (let i=0; i < ipTest.length; i++){\n//         if (validIP(ipTest[i])){\n//             ip_collection.push(ipTest[i])\n//         }\n//     }\n//     locateDetails()\n// }\n\n// window.ip_collection = ip_collection\n\n//working API call to gather IP geo location details\nconst locate = new _location__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\nlet listCities = [];\nlet listLongitude = [];\nlet listLatitude = [];\n\n// window.listCities = listCities\n// window.listLongitude = listLongitude\n// window.listLatitude = listLatitude\n\n//iterates through array of collected IPs\n//due to API restrictions each API call from getLocation\n//must wait one second per request\n//adds API data into an \n\nfunction locateDetails() {\n  const destinationDetails = document.getElementById(\"destination-details\");\n  for (let i = 0; i < ip_collection.length; i++) {\n    // setTimeout(() => {\n    let geolocation = locate.getLocation(ip_collection[i]);\n    geolocation.then(data => {\n      console.log(data);\n      console.log(data.loc);\n      let location = data.loc.split(',');\n      listCities.push(data.city);\n      listLatitude.push(parseFloat(location[0]));\n      listLongitude.push(parseFloat(location[1]));\n      console.log(location);\n\n      // if (!listLongitude.includes(data.longitude)){\n      //     listCities.push(data.city)\n      //     listLongitude.push(data.longitude)\n      //     listLatitude.push(data.latitude)\n      //     console.log(ip_collection)\n      //     console.log(listCities)\n      if (listCities.length === ip_collection.length) {\n        spinner.classList.add('hidden');\n        destinationDetails.classList.remove('hidden');\n        macbook.classList.remove('hidden');\n        destinationH1.innerHTML = `You've arrive at ${listCities[0]}`;\n        makeMap();\n      }\n      // }\n    });\n    // },i * 1500)\n  }\n}\n\n// window.locateDetails = locateDetails\n\n//Makes a map as an instance of Map\n//Takes in the first positions from listLatitude and listLongitude\n//Create a new script HTML element\n//Fetches the google maps API key from the proxy server\n//Sets the new script src to equal our google maps API call\n//Google maps API requires a callback function, hence map.initMap\nlet map;\nfunction makeMap() {\n  map = new _maps__WEBPACK_IMPORTED_MODULE_2__[\"default\"](listLatitude[0], listLongitude[0]);\n  map.initMap;\n  let script = document.createElement('script');\n  //setting src html tag equal to my google API Call\n  // fetch(\"https://mapping-the-matrix.onrender.com/goog\").then(res => {\n  fetch(\"http://localhost:5001/goog\").then(res => {\n    return res.text();\n  }).then(key => {\n    // console.log(key)\n    script.src = `https://maps.googleapis.com/maps/api/js?key=${key}&callback=map.initMap`;\n  });\n  //setting async true on our HTML element\n  script.async = true;\n  //adding html element to our head section of our HTML document\n  document.head.appendChild(script);\n  //setting map on the window\n  window.map = map;\n}\n\n//Listens for next-button click\n//On button click increment i by 1\n//Set the arrived destination to the updated city\n//update the map and marker to updated coordinates\n//if we've reached the end we provide summary view of all mapped location\nlet i = 0;\nlet destinationH1 = document.getElementById(\"destination\");\ndestinationH1.innerHTML = `You've arrived at ${listCities[i]}`;\nconst nextButton = document.getElementById(\"next-button\");\nconst onNextClick = function (event) {\n  event.preventDefault();\n  i += 1;\n  destinationH1.innerHTML = `You've arrived at ${listCities[i]}`;\n  map.updateMapAndMarkerPosition(listLatitude[i], listLongitude[i]);\n  if (i === listLatitude.length) {\n    destinationH1.innerHTML = \"Your Mapped Matrix\";\n    map.addMarkers(listLatitude, listLongitude);\n    nextButton.removeEventListener('click', onNextClick);\n  }\n};\nnextButton.addEventListener('click', onNextClick);\n\n//set canvas to to HTML canvas element\nconst canvas = document.getElementById(\"canvas\");\nconst ctx = canvas.getContext(\"2d\");\n//set canvas to the current window width and height\ncanvas.width = window.innerWidth;\ncanvas.height = window.innerHeight;\n//color and font style\nctx.fillStyle = \"#0F0\";\nctx.font = \"16px monospace\";\nconst chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\nconst charArr = chars.split(\"\");\n//number of columns needed based on the width of the window\nconst columns = canvas.width / 16;\nlet drops = [];\n//set each element in column equal to 1\nfor (let i = 0; i < columns; i++) {\n  drops[i] = 1;\n}\nfunction draw() {\n  //set canvas to semi-transparent black\n  ctx.fillStyle = \"rgba(0, 0, 0, 0.05)\";\n  //draws rectangle based on canvas width and heigh that we set earlier\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\n  //set fillstyle to green\n  ctx.fillStyle = \"#0F0\";\n  for (let i = 0; i < drops.length; i++) {\n    //sets char index to hold a random index up to the char Array length\n    const charIndex = Math.floor(Math.random() * charArr.length);\n    //set char to the random char\n    const char = charArr[charIndex];\n    //fills text\n    ctx.fillText(char, i * 16, drops[i] * 16);\n    //resets drop back to 0, otherwise increment\n    if (drops[i] * 16 > canvas.height && Math.random() > 0.95) {\n      drops[i] = 0;\n    }\n    drops[i]++;\n  }\n}\n\n//resizes the canvas based on the state of the window and height\nfunction resizeCanvas() {\n  canvas.width = window.innerWidth;\n  canvas.height = window.innerHeight;\n  const columns = canvas.width / 16;\n  drops = [];\n  for (let i = 0; i < columns; i++) {\n    drops[i] = 1;\n  }\n}\n\n//listening for window resize, runs callback if it does\nwindow.addEventListener('resize', resizeCanvas);\nresizeCanvas();\ncanvas.addEventListener(\"mousemove\", function (event) {\n  const mouseX = event.clientX - canvas.offsetLeft;\n  const mouseY = event.clientY - canvas.offsetTop;\n  const column = Math.floor(mouseX / 16);\n  const row = Math.floor(mouseY / 16);\n  ctx.fillStyle = \"#ff3333\";\n  for (let i = column - 1; i <= column + 1; i++) {\n    for (let j = row - 1; j <= row + 1; j++) {\n      if (i >= 0 && i < columns && j >= 0 && j < drops.length) {\n        ctx.fillText(charArr[Math.floor(Math.random() * charArr.length)], i * 16, drops[j] * 16);\n      }\n    }\n  }\n});\n\n//draws canvas every 33 miliseconds\nsetInterval(draw, 33);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RCxJQUFJLENBQUNFLE1BQU0sRUFBRSxHQUFHUixPQUFPLENBQUN4QyxNQUFNLENBQUMsQ0FBQyxFQUFFRCxDQUFDLEdBQUcsRUFBRSxFQUFFMkMsS0FBSyxDQUFDa0IsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO01BQzVGO0lBQ0o7RUFDSjtBQUNKLENBQUMsQ0FBQzs7QUFHRjtBQUNBQyxXQUFXLENBQUNsQixJQUFJLEVBQUUsRUFBRSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFwX21hdHJpeC8uL3NyYy9pbmRleC5qcz9iNjM1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBUcmFjZXJvdXRlIGZyb20gXCIuL3RyYWNlcm91dGVcIjtcbmltcG9ydCBMb2NhdGlvbiBmcm9tIFwiLi9sb2NhdGlvblwiO1xuaW1wb3J0IE1hcCBmcm9tIFwiLi9tYXBzXCI7XG5pbXBvcnQgeyBhc3luYyB9IGZyb20gXCJyZWdlbmVyYXRvci1ydW50aW1lXCI7XG5cbi8vU2V0cyBnZXRTdGFydGVkIHRvIHRoZSBnZXQtc3RhcnRlZCBIVE1MIGVsZW1lbnRzXG5jb25zdCBnZXRTdGFydGVkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJnZXQtc3RhcnRlZFwiKVxuY29uc3QgbWFjYm9vayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibWFjYm9vay1jb250YWluZXJcIilcblxuLy9MaXN0ZW5zIGZvciBhIGNsaWNrIG9uIHRoZSBnZXQtc3RhcnRlZCBidXR0b25cbi8vVG8gc3VtbS4gdGhpcyBoaWRlcyB0aGUgaG9tZXBhZ2UgYW5kIHNob3dzIHRoZSBlbnRlciBkZXN0aW5hdGlvbiBjb250YWluZXJcbmdldFN0YXJ0ZWQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAvL3ByZXZlbnRzIHRoZSBkZWZhdWx0IG9mIGxvYWRpbmcgYSBwYWdlIG9uIGNsaWNrXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAvL3NhdmVzIHRoZSBIVE1MIGNvbnRhaW5lciB3ZWxjb21lIGNvbnRhaW5lclxuICAgIGNvbnN0IHdlbGNvbWVQYWdlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ3ZWxjb21lLWNvbnRhaW5lclwiKVxuICAgIC8vc2F2ZXMgdGhlIEhUTkwgY29udGFpbmVyIGRlc3RpbmF0aW9uc1xuICAgIGNvbnN0IGVudGVyRGVzdGluYXRpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImVudGVyLWRlc3RpbmF0aW9uXCIpXG4gICAgLy9BZGRzIGhpZGRlbiB0byB0aGUgSFRNTCBjb250YWluZXIgXG4gICAgd2VsY29tZVBhZ2UuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJylcbiAgICAvL1Jtb2V2ZXMgaGlkZGVuIGZyb20gdGhlIEhUTUwgY29udGFpbmVyIGRlc3RpbmF0aW9uXG4gICAgZW50ZXJEZXN0aW5hdGlvbi5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKVxuICAgIC8vUmVtb3ZlcyBoaWRkZW4gZnJvbSB0aGUgSFRNTCBjb250YWluZXIgbWFjYm9vay1jb250YWluZXJcbiAgICBtYWNib29rLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpXG59KVxuXG5cbmNvbnN0IGxldHNHbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZG9tYWluLXN1Ym1pdFwiKVxuXG4vL1N1bW1hcml6ZSwgdGhpcyBmdW5jdGlvbiB3YWl0cyBmb3IgdGhpcyBmb3IgbGV0cyBnbyB0byBiZSBjbGlja2VkXG4vL0hpZGVzIEhUTUwgZWxlbWVudHMsIHNob3dzIHRoZSBkZXN0aW5hdGlvbnMgZGV0YWlscyBjb250YWluZXJcbi8vR2F0aGVycyB1c2VyIGlucHV0IGFuZCBwYXNzZXMgaXQgdG8gcm91dGVzIGZ1bmN0aW9uXG5jb25zdCBzcGlubmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzcGlubmVyXCIpXG5cbmxldHNHby5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgIGNvbnN0IGRvbWFpbklucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkb21haW5cIikudmFsdWVcbiAgICBpZiAoZG9tYWluSW5wdXQgPT09IFwiXCIpe1xuICAgICAgICBhbGVydChcIlBsZWFzZSBlbnRlciBhIGRvbWFpbiBuYW1lLCBpLmUuIGdvb2dsZS5jb20sIGZhY2Vib29rLmNvbSwgdHdpdHRlci5jb20sIGV0Yy5cIilcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgZW50ZXJEZXN0aW5hdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZW50ZXItZGVzdGluYXRpb25cIilcbiAgICAvLyBjb25zdCBkZXN0aW5hdGlvbkRldGFpbHMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRlc3RpbmF0aW9uLWRldGFpbHNcIilcbiAgICBlbnRlckRlc3RpbmF0aW9uLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpXG4gICAgbWFjYm9vay5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKVxuICAgIHNwaW5uZXIuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJylcbiAgICAvLyBkZXN0aW5hdGlvbkRldGFpbHMuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJylcbiAgICAvLyBkb21haW5JbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZG9tYWluXCIpLnZhbHVlXG4gICAgXG4gICAgLy8gY29uc29sZS5sb2coZG9tYWluSW5wdXQpXG4gICAgcm91dGVzKGRvbWFpbklucHV0KVxufSlcblxuLy8gd2luZG93LmRvbWFpbklucHV0ID0gZG9tYWluSW5wdXRcblxuLy9tYWtlcyBhIG5ldyB0cmFjZXJvdXRlIGluc3RhbmNlXG5jb25zdCB0cmFjZVJvdXRlID0gbmV3IFRyYWNlcm91dGVcbi8vYXJyYXkgb2YgY29sbGVjdGVkIElQIGZyb20gdGhlIHJvdXRlcyBmdW5jdGlvblxubGV0IGlwVGVzdCA9IFsnMC4wLjAuMCcsICcwLjAuMC4wJywgJ2FlMi4zNjEyLmVkZ2U2Lldhc2hpbmd0b24xMi5sZXZlbDMubmV0JywgJzQuNjguMzguNicsICcxMjkuMTM0Ljk5LjIyMicsICcxNzMuMjUyLjY3LjYzJ11cbmxldCBpcF9jb2xsZWN0aW9uID0gW11cblxuXG5jb25zdCBoYXNBbHBoYUNoYXJhY3RlcnMgPSBmdW5jdGlvbihpcCl7XG4gICAgaWYgKGlwLm1hdGNoKC9bYS16XS9pKSl7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxufVxuXG5jb25zdCB2YWxpZElQID0gZnVuY3Rpb24oaXApe1xuICAgIGlmIChpcCA9PT0gXCIwLjAuMC4wXCIgfHwgaXAgPT09IFwiKlwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSBpZiAoaGFzQWxwaGFDaGFyYWN0ZXJzKGlwKSl7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxufVxuXG5cblxuLy9TdW1tYXJpemUsIHRha2VzIGRvbWFpbiBpbnB1dCBmcm9tIHRoZSBMZXRzIGdvIGV2ZW50IGxpc3RlbmVyXG4vL2NhbGxzIHRoZSBjbGFzcyBmdW5jdGlvbiBnZXRSb3V0ZSBhbmQgcGFzc2VzIHRoZSBkb21haW4gaW5wdXRcbi8vZ2V0IHJvdXRlIGlzIGFuIEFQSSBmZXRjaCBhbmQgcGFzc2VzIGVhY2ggaG9wIGludG8gXG4vL2NhbGxzIHRoZSBsb2NhdGUgZGV0YWlscyBmdW5jdGlvbiB3aGVuIGRvbmVcbmNvbnN0IHJvdXRlcyA9IGZ1bmN0aW9uKGRvbWFpbil7XG4gICAgY29uc3Qgcm91dGUgPSB0cmFjZVJvdXRlLmdldFJvdXRlKGRvbWFpbilcbiAgICByb3V0ZS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGRhdGEucmVzcG9uc2UuaG9wcywgXCJob3BzIGNvbnNvbGUgbG9nXCIpXG4gICAgICAgIGZvciAobGV0IG51bWJlciBpbiBkYXRhLnJlc3BvbnNlLmhvcHMpIHtcbiAgICAgICAgICAgIGlmICh2YWxpZElQKGRhdGEucmVzcG9uc2UuaG9wc1tudW1iZXJdLmlwKSkge1xuICAgICAgICAgICAgICAgIGlwX2NvbGxlY3Rpb24ucHVzaChkYXRhLnJlc3BvbnNlLmhvcHNbbnVtYmVyXS5pcClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsb2NhdGVEZXRhaWxzKClcbiAgICB9KSAgICBcbn07XG5cbi8vIGNvbnN0IHJvdXRlcyA9IGZ1bmN0aW9uKGRvbWFpbil7XG4vLyAgICAgZm9yIChsZXQgaT0wOyBpIDwgaXBUZXN0Lmxlbmd0aDsgaSsrKXtcbi8vICAgICAgICAgaWYgKHZhbGlkSVAoaXBUZXN0W2ldKSl7XG4vLyAgICAgICAgICAgICBpcF9jb2xsZWN0aW9uLnB1c2goaXBUZXN0W2ldKVxuLy8gICAgICAgICB9XG4vLyAgICAgfVxuLy8gICAgIGxvY2F0ZURldGFpbHMoKVxuLy8gfVxuXG5cbi8vIHdpbmRvdy5pcF9jb2xsZWN0aW9uID0gaXBfY29sbGVjdGlvblxuXG4vL3dvcmtpbmcgQVBJIGNhbGwgdG8gZ2F0aGVyIElQIGdlbyBsb2NhdGlvbiBkZXRhaWxzXG5jb25zdCBsb2NhdGUgPSBuZXcgTG9jYXRpb25cblxubGV0IGxpc3RDaXRpZXMgPSBbXVxubGV0IGxpc3RMb25naXR1ZGUgPSBbXVxubGV0IGxpc3RMYXRpdHVkZSA9IFtdXG5cbi8vIHdpbmRvdy5saXN0Q2l0aWVzID0gbGlzdENpdGllc1xuLy8gd2luZG93Lmxpc3RMb25naXR1ZGUgPSBsaXN0TG9uZ2l0dWRlXG4vLyB3aW5kb3cubGlzdExhdGl0dWRlID0gbGlzdExhdGl0dWRlXG5cbi8vaXRlcmF0ZXMgdGhyb3VnaCBhcnJheSBvZiBjb2xsZWN0ZWQgSVBzXG4vL2R1ZSB0byBBUEkgcmVzdHJpY3Rpb25zIGVhY2ggQVBJIGNhbGwgZnJvbSBnZXRMb2NhdGlvblxuLy9tdXN0IHdhaXQgb25lIHNlY29uZCBwZXIgcmVxdWVzdFxuLy9hZGRzIEFQSSBkYXRhIGludG8gYW4gXG5cbmZ1bmN0aW9uIGxvY2F0ZURldGFpbHMoKXtcbiAgICBjb25zdCBkZXN0aW5hdGlvbkRldGFpbHMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRlc3RpbmF0aW9uLWRldGFpbHNcIilcbiAgICBmb3IgKGxldCBpPTAgOyBpIDwgaXBfY29sbGVjdGlvbi5sZW5ndGg7IGkrKyl7XG4gICAgICAgIC8vIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGdlb2xvY2F0aW9uID0gbG9jYXRlLmdldExvY2F0aW9uKGlwX2NvbGxlY3Rpb25baV0pXG4gICAgICAgICAgICBnZW9sb2NhdGlvbi50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhLmxvYylcbiAgICAgICAgICAgICAgICBsZXQgbG9jYXRpb24gPSBkYXRhLmxvYy5zcGxpdCgnLCcpXG4gICAgICAgICAgICAgICAgbGlzdENpdGllcy5wdXNoKGRhdGEuY2l0eSlcbiAgICAgICAgICAgICAgICBsaXN0TGF0aXR1ZGUucHVzaChwYXJzZUZsb2F0KGxvY2F0aW9uWzBdKSlcbiAgICAgICAgICAgICAgICBsaXN0TG9uZ2l0dWRlLnB1c2gocGFyc2VGbG9hdChsb2NhdGlvblsxXSkpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cobG9jYXRpb24pXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gaWYgKCFsaXN0TG9uZ2l0dWRlLmluY2x1ZGVzKGRhdGEubG9uZ2l0dWRlKSl7XG4gICAgICAgICAgICAgICAgLy8gICAgIGxpc3RDaXRpZXMucHVzaChkYXRhLmNpdHkpXG4gICAgICAgICAgICAgICAgLy8gICAgIGxpc3RMb25naXR1ZGUucHVzaChkYXRhLmxvbmdpdHVkZSlcbiAgICAgICAgICAgICAgICAvLyAgICAgbGlzdExhdGl0dWRlLnB1c2goZGF0YS5sYXRpdHVkZSlcbiAgICAgICAgICAgICAgICAvLyAgICAgY29uc29sZS5sb2coaXBfY29sbGVjdGlvbilcbiAgICAgICAgICAgICAgICAvLyAgICAgY29uc29sZS5sb2cobGlzdENpdGllcylcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBsaXN0Q2l0aWVzLmxlbmd0aCA9PT0gaXBfY29sbGVjdGlvbi5sZW5ndGggKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwaW5uZXIuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uRGV0YWlscy5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFjYm9vay5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25IMS5pbm5lckhUTUwgPSBgWW91J3ZlIGFycml2ZSBhdCAke2xpc3RDaXRpZXNbMF19YFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZU1hcCgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAvLyB9LGkgKiAxNTAwKVxuICAgIH1cbn0gXG5cbi8vIHdpbmRvdy5sb2NhdGVEZXRhaWxzID0gbG9jYXRlRGV0YWlsc1xuXG5cblxuXG4vL01ha2VzIGEgbWFwIGFzIGFuIGluc3RhbmNlIG9mIE1hcFxuLy9UYWtlcyBpbiB0aGUgZmlyc3QgcG9zaXRpb25zIGZyb20gbGlzdExhdGl0dWRlIGFuZCBsaXN0TG9uZ2l0dWRlXG4vL0NyZWF0ZSBhIG5ldyBzY3JpcHQgSFRNTCBlbGVtZW50XG4vL0ZldGNoZXMgdGhlIGdvb2dsZSBtYXBzIEFQSSBrZXkgZnJvbSB0aGUgcHJveHkgc2VydmVyXG4vL1NldHMgdGhlIG5ldyBzY3JpcHQgc3JjIHRvIGVxdWFsIG91ciBnb29nbGUgbWFwcyBBUEkgY2FsbFxuLy9Hb29nbGUgbWFwcyBBUEkgcmVxdWlyZXMgYSBjYWxsYmFjayBmdW5jdGlvbiwgaGVuY2UgbWFwLmluaXRNYXBcbmxldCBtYXA7XG5mdW5jdGlvbiBtYWtlTWFwKCl7XG4gICAgbWFwID0gbmV3IE1hcChsaXN0TGF0aXR1ZGVbMF0sIGxpc3RMb25naXR1ZGVbMF0pXG4gICAgbWFwLmluaXRNYXBcbiAgICBsZXQgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcbiAgICAvL3NldHRpbmcgc3JjIGh0bWwgdGFnIGVxdWFsIHRvIG15IGdvb2dsZSBBUEkgQ2FsbFxuICAgIC8vIGZldGNoKFwiaHR0cHM6Ly9tYXBwaW5nLXRoZS1tYXRyaXgub25yZW5kZXIuY29tL2dvb2dcIikudGhlbihyZXMgPT4ge1xuICAgIGZldGNoKFwiaHR0cDovL2xvY2FsaG9zdDo1MDAxL2dvb2dcIikudGhlbihyZXMgPT4ge1xuICAgICAgICByZXR1cm4gcmVzLnRleHQoKVxuICAgIH0pLnRoZW4oa2V5ID0+IHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coa2V5KVxuICAgICAgICBzY3JpcHQuc3JjID0gYGh0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9qcz9rZXk9JHtrZXl9JmNhbGxiYWNrPW1hcC5pbml0TWFwYFxuICAgIH0pXG4gICAgLy9zZXR0aW5nIGFzeW5jIHRydWUgb24gb3VyIEhUTUwgZWxlbWVudFxuICAgIHNjcmlwdC5hc3luYyA9IHRydWVcbiAgICAvL2FkZGluZyBodG1sIGVsZW1lbnQgdG8gb3VyIGhlYWQgc2VjdGlvbiBvZiBvdXIgSFRNTCBkb2N1bWVudFxuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuICAgIC8vc2V0dGluZyBtYXAgb24gdGhlIHdpbmRvd1xuICAgIHdpbmRvdy5tYXAgPSBtYXBcbn1cblxuXG5cbi8vTGlzdGVucyBmb3IgbmV4dC1idXR0b24gY2xpY2tcbi8vT24gYnV0dG9uIGNsaWNrIGluY3JlbWVudCBpIGJ5IDFcbi8vU2V0IHRoZSBhcnJpdmVkIGRlc3RpbmF0aW9uIHRvIHRoZSB1cGRhdGVkIGNpdHlcbi8vdXBkYXRlIHRoZSBtYXAgYW5kIG1hcmtlciB0byB1cGRhdGVkIGNvb3JkaW5hdGVzXG4vL2lmIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCB3ZSBwcm92aWRlIHN1bW1hcnkgdmlldyBvZiBhbGwgbWFwcGVkIGxvY2F0aW9uXG5sZXQgaSA9IDBcbmxldCBkZXN0aW5hdGlvbkgxID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkZXN0aW5hdGlvblwiKVxuZGVzdGluYXRpb25IMS5pbm5lckhUTUwgPSBgWW91J3ZlIGFycml2ZWQgYXQgJHtsaXN0Q2l0aWVzW2ldfWBcbmNvbnN0IG5leHRCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm5leHQtYnV0dG9uXCIpXG5jb25zdCBvbk5leHRDbGljayA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGkgKz0xO1xuICAgIGRlc3RpbmF0aW9uSDEuaW5uZXJIVE1MID0gYFlvdSd2ZSBhcnJpdmVkIGF0ICR7bGlzdENpdGllc1tpXX1gXG4gICAgbWFwLnVwZGF0ZU1hcEFuZE1hcmtlclBvc2l0aW9uKGxpc3RMYXRpdHVkZVtpXSwgbGlzdExvbmdpdHVkZVtpXSlcbiAgICBpZiAoIGkgPT09IGxpc3RMYXRpdHVkZS5sZW5ndGgpe1xuICAgICAgICBkZXN0aW5hdGlvbkgxLmlubmVySFRNTCA9IFwiWW91ciBNYXBwZWQgTWF0cml4XCJcbiAgICAgICAgbWFwLmFkZE1hcmtlcnMobGlzdExhdGl0dWRlLCBsaXN0TG9uZ2l0dWRlKVxuICAgICAgICBuZXh0QnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25OZXh0Q2xpY2spXG4gICAgfVxufVxubmV4dEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uTmV4dENsaWNrKVxuXG5cbi8vc2V0IGNhbnZhcyB0byB0byBIVE1MIGNhbnZhcyBlbGVtZW50XG5jb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNhbnZhc1wiKTtcbmNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4vL3NldCBjYW52YXMgdG8gdGhlIGN1cnJlbnQgd2luZG93IHdpZHRoIGFuZCBoZWlnaHRcbmNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuY2FudmFzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbi8vY29sb3IgYW5kIGZvbnQgc3R5bGVcbmN0eC5maWxsU3R5bGUgPSBcIiMwRjBcIjtcbmN0eC5mb250ID0gXCIxNnB4IG1vbm9zcGFjZVwiO1xuXG5cblxuY29uc3QgY2hhcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMDEyMzQ1Njc4OVwiO1xuY29uc3QgY2hhckFyciA9IGNoYXJzLnNwbGl0KFwiXCIpO1xuLy9udW1iZXIgb2YgY29sdW1ucyBuZWVkZWQgYmFzZWQgb24gdGhlIHdpZHRoIG9mIHRoZSB3aW5kb3dcbmNvbnN0IGNvbHVtbnMgPSBjYW52YXMud2lkdGggLyAxNjtcbmxldCBkcm9wcyA9IFtdO1xuLy9zZXQgZWFjaCBlbGVtZW50IGluIGNvbHVtbiBlcXVhbCB0byAxXG5mb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbnM7IGkrKykge1xuICAgIGRyb3BzW2ldID0gMTtcbn1cblxuXG5mdW5jdGlvbiBkcmF3KCkge1xuICAgIC8vc2V0IGNhbnZhcyB0byBzZW1pLXRyYW5zcGFyZW50IGJsYWNrXG4gICAgY3R4LmZpbGxTdHlsZSA9IFwicmdiYSgwLCAwLCAwLCAwLjA1KVwiO1xuICAgIC8vZHJhd3MgcmVjdGFuZ2xlIGJhc2VkIG9uIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2ggdGhhdCB3ZSBzZXQgZWFybGllclxuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIC8vc2V0IGZpbGxzdHlsZSB0byBncmVlblxuICAgIGN0eC5maWxsU3R5bGUgPSBcIiMwRjBcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRyb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vc2V0cyBjaGFyIGluZGV4IHRvIGhvbGQgYSByYW5kb20gaW5kZXggdXAgdG8gdGhlIGNoYXIgQXJyYXkgbGVuZ3RoXG4gICAgICAgIGNvbnN0IGNoYXJJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJBcnIubGVuZ3RoKTtcbiAgICAgICAgLy9zZXQgY2hhciB0byB0aGUgcmFuZG9tIGNoYXJcbiAgICAgICAgY29uc3QgY2hhciA9IGNoYXJBcnJbY2hhckluZGV4XTtcbiAgICAgICAgLy9maWxscyB0ZXh0XG4gICAgICAgIGN0eC5maWxsVGV4dChjaGFyLCBpICogMTYsIGRyb3BzW2ldICogMTYpO1xuICAgICAgICAvL3Jlc2V0cyBkcm9wIGJhY2sgdG8gMCwgb3RoZXJ3aXNlIGluY3JlbWVudFxuICAgICAgICBpZiAoZHJvcHNbaV0gKiAxNiA+IGNhbnZhcy5oZWlnaHQgJiYgTWF0aC5yYW5kb20oKSA+IDAuOTUpIHtcbiAgICAgICAgICAgIGRyb3BzW2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgICBkcm9wc1tpXSsrO1xuICAgIH1cbn1cblxuLy9yZXNpemVzIHRoZSBjYW52YXMgYmFzZWQgb24gdGhlIHN0YXRlIG9mIHRoZSB3aW5kb3cgYW5kIGhlaWdodFxuZnVuY3Rpb24gcmVzaXplQ2FudmFzKCl7XG4gICAgY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGhcbiAgICBjYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0XG4gICAgY29uc3QgY29sdW1ucyA9IGNhbnZhcy53aWR0aCAvIDE2XG4gICAgZHJvcHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbnM7IGkrKykge1xuICAgICAgICBkcm9wc1tpXSA9IDFcbiAgICB9XG59XG5cbi8vbGlzdGVuaW5nIGZvciB3aW5kb3cgcmVzaXplLCBydW5zIGNhbGxiYWNrIGlmIGl0IGRvZXNcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemVDYW52YXMpXG5yZXNpemVDYW52YXMoKTtcblxuXG5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbihldmVudCl7XG5cbiAgICBjb25zdCBtb3VzZVggPSBldmVudC5jbGllbnRYIC0gY2FudmFzLm9mZnNldExlZnQ7XG4gICAgY29uc3QgbW91c2VZID0gZXZlbnQuY2xpZW50WSAtIGNhbnZhcy5vZmZzZXRUb3A7XG5cbiAgICBjb25zdCBjb2x1bW4gPSBNYXRoLmZsb29yKG1vdXNlWCAvIDE2KTtcbiAgICBjb25zdCByb3cgPSBNYXRoLmZsb29yKG1vdXNlWSAvIDE2KTtcblxuICAgIGN0eC5maWxsU3R5bGUgPSBcIiNmZjMzMzNcIjtcbiAgICBmb3IgKGxldCBpID0gY29sdW1uIC0gMTsgaSA8PSBjb2x1bW4gKyAxOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IHJvdyAtIDE7IGogPD0gcm93ICsgMTsgaisrKSB7XG4gICAgICAgICAgICBpZiAoaSA+PSAwICYmIGkgPCBjb2x1bW5zICYmIGogPj0gMCAmJiBqIDwgZHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGNoYXJBcnJbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhckFyci5sZW5ndGgpXSwgaSAqIDE2LCBkcm9wc1tqXSAqIDE2KTtcbiAgICAgICAgICAgIH0gIFxuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuLy9kcmF3cyBjYW52YXMgZXZlcnkgMzMgbWlsaXNlY29uZHNcbnNldEludGVydmFsKGRyYXcsIDMzKTsiXSwibmFtZXMiOlsiVHJhY2Vyb3V0ZSIsIkxvY2F0aW9uIiwiTWFwIiwiYXN5bmMiLCJnZXRTdGFydGVkIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsIm1hY2Jvb2siLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsIndlbGNvbWVQYWdlIiwiZW50ZXJEZXN0aW5hdGlvbiIsImNsYXNzTGlzdCIsImFkZCIsInJlbW92ZSIsImxldHNHbyIsInNwaW5uZXIiLCJkb21haW5JbnB1dCIsInZhbHVlIiwiYWxlcnQiLCJyb3V0ZXMiLCJ0cmFjZVJvdXRlIiwiaXBUZXN0IiwiaXBfY29sbGVjdGlvbiIsImhhc0FscGhhQ2hhcmFjdGVycyIsImlwIiwibWF0Y2giLCJ2YWxpZElQIiwiZG9tYWluIiwicm91dGUiLCJnZXRSb3V0ZSIsInRoZW4iLCJkYXRhIiwibnVtYmVyIiwicmVzcG9uc2UiLCJob3BzIiwicHVzaCIsImxvY2F0ZURldGFpbHMiLCJsb2NhdGUiLCJsaXN0Q2l0aWVzIiwibGlzdExvbmdpdHVkZSIsImxpc3RMYXRpdHVkZSIsImRlc3RpbmF0aW9uRGV0YWlscyIsImkiLCJsZW5ndGgiLCJnZW9sb2NhdGlvbiIsImdldExvY2F0aW9uIiwiY29uc29sZSIsImxvZyIsImxvYyIsImxvY2F0aW9uIiwic3BsaXQiLCJjaXR5IiwicGFyc2VGbG9hdCIsImRlc3RpbmF0aW9uSDEiLCJpbm5lckhUTUwiLCJtYWtlTWFwIiwibWFwIiwiaW5pdE1hcCIsInNjcmlwdCIsImNyZWF0ZUVsZW1lbnQiLCJmZXRjaCIsInJlcyIsInRleHQiLCJrZXkiLCJzcmMiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJ3aW5kb3ciLCJuZXh0QnV0dG9uIiwib25OZXh0Q2xpY2siLCJ1cGRhdGVNYXBBbmRNYXJrZXJQb3NpdGlvbiIsImFkZE1hcmtlcnMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsIndpZHRoIiwiaW5uZXJXaWR0aCIsImhlaWdodCIsImlubmVySGVpZ2h0IiwiZmlsbFN0eWxlIiwiZm9udCIsImNoYXJzIiwiY2hhckFyciIsImNvbHVtbnMiLCJkcm9wcyIsImRyYXciLCJmaWxsUmVjdCIsImNoYXJJbmRleCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImNoYXIiLCJmaWxsVGV4dCIsInJlc2l6ZUNhbnZhcyIsIm1vdXNlWCIsImNsaWVudFgiLCJvZmZzZXRMZWZ0IiwibW91c2VZIiwiY2xpZW50WSIsIm9mZnNldFRvcCIsImNvbHVtbiIsInJvdyIsImoiLCJzZXRJbnRlcnZhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/location.js":
/*!*************************!*\
  !*** ./src/location.js ***!
  \*************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nclass Location {\n  constructor() {}\n  async getLocation(ip) {\n    //api call to gather geolocation info\n    // const location = await fetch(`https://mapping-the-matrix.onrender.com/location?ip=${ip}`)\n    const location = await fetch(`http://localhost:5001/location?ip=${ip}`);\n    const data = await location.json();\n    return data;\n  }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (Location);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbG9jYXRpb24uanMuanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU1BLFFBQVE7RUFDVkMsV0FBV0EsQ0FBQSxFQUFFLENBRWI7RUFDQSxNQUFNQyxXQUFXQSxDQUFDQyxFQUFFLEVBQUM7SUFDakI7SUFDQTtJQUNBLE1BQU1DLFFBQVEsR0FBRyxNQUFNQyxLQUFLLENBQUUscUNBQW9DRixFQUFHLEVBQUMsQ0FBQztJQUN2RSxNQUFNRyxJQUFJLEdBQUcsTUFBTUYsUUFBUSxDQUFDRyxJQUFJLEVBQUU7SUFDbEMsT0FBT0QsSUFBSTtFQUNmO0FBQ0o7QUFFQSwrREFBZU4sUUFBUSIsInNvdXJjZXMiOlsid2VicGFjazovL21hcF9tYXRyaXgvLi9zcmMvbG9jYXRpb24uanM/MDhhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBMb2NhdGlvbntcbiAgICBjb25zdHJ1Y3Rvcigpe1xuXG4gICAgfVxuICAgIGFzeW5jIGdldExvY2F0aW9uKGlwKXtcbiAgICAgICAgLy9hcGkgY2FsbCB0byBnYXRoZXIgZ2VvbG9jYXRpb24gaW5mb1xuICAgICAgICAvLyBjb25zdCBsb2NhdGlvbiA9IGF3YWl0IGZldGNoKGBodHRwczovL21hcHBpbmctdGhlLW1hdHJpeC5vbnJlbmRlci5jb20vbG9jYXRpb24/aXA9JHtpcH1gKVxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGF3YWl0IGZldGNoKGBodHRwOi8vbG9jYWxob3N0OjUwMDEvbG9jYXRpb24/aXA9JHtpcH1gKVxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgbG9jYXRpb24uanNvbigpXG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMb2NhdGlvbiJdLCJuYW1lcyI6WyJMb2NhdGlvbiIsImNvbnN0cnVjdG9yIiwiZ2V0TG9jYXRpb24iLCJpcCIsImxvY2F0aW9uIiwiZmV0Y2giLCJkYXRhIiwianNvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/location.js\n");

/***/ }),

/***/ "./src/maps.js":
/*!*********************!*\
  !*** ./src/maps.js ***!
  \*********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nclass Map {\n  constructor(latitude, longitude) {\n    _defineProperty(this, \"initMap\", function () {\n      const options = {\n        zoom: 11,\n        center: {\n          lat: this.latitude,\n          lng: this.longitude\n        }\n      };\n      this.map = new google.maps.Map(document.getElementById('map'), options);\n      this.markers.push(new google.maps.Marker({\n        position: {\n          lat: this.latitude,\n          lng: this.longitude\n        },\n        map: this.map,\n        animation: google.maps.Animation.DROP\n      }));\n    });\n    _defineProperty(this, \"updateMapAndMarkerPosition\", function (lat, long) {\n      if (!isNaN(lat) && !isNaN(long)) {\n        let newCenter = new google.maps.LatLng(lat, long);\n        this.map.setCenter(newCenter);\n        this.markers[0].setPosition(newCenter);\n      }\n    });\n    _defineProperty(this, \"addMarkers\", function (lat, long) {\n      this.markers.forEach(marker => marker.setMap(null));\n      this.markers = [];\n      const bounds = new google.maps.LatLngBounds();\n      for (let i = 0; i < lat.length; i++) {\n        const marker = new google.maps.Marker({\n          position: {\n            lat: lat[i],\n            lng: long[i]\n          },\n          map: this.map,\n          label: (i + 1).toString()\n        });\n        this.markers.push(marker);\n        bounds.extend(marker.getPosition());\n      }\n      this.map.fitBounds(bounds);\n    });\n    this.map = null;\n    this.longitude = longitude;\n    this.latitude = latitude;\n    this.markers = [];\n  }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (Map);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMxQixJQUFJLENBQUNELFFBQVEsR0FBR0EsUUFBUTtJQUN4QixJQUFJLENBQUNhLE9BQU8sR0FBRyxFQUFFO0VBQ3JCO0FBb0NGO0FBRUEsK0RBQWVmLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXBfbWF0cml4Ly4vc3JjL21hcHMuanM/NTBiNyJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBNYXB7XG4gIGNvbnN0cnVjdG9yKGxhdGl0dWRlLCBsb25naXR1ZGUpIHtcbiAgICAgIHRoaXMubWFwID0gbnVsbDtcbiAgICAgIHRoaXMubG9uZ2l0dWRlID0gbG9uZ2l0dWRlXG4gICAgICB0aGlzLmxhdGl0dWRlID0gbGF0aXR1ZGVcbiAgICAgIHRoaXMubWFya2VycyA9IFtdO1xuICB9XG5cbiAgaW5pdE1hcCA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7ICAgICBcbiAgICAgICAgem9vbTogMTEsXG4gICAgICAgIGNlbnRlcjogeyBsYXQ6IHRoaXMubGF0aXR1ZGUsIGxuZzogdGhpcy5sb25naXR1ZGUgfVxuICAgIH1cbiAgICB0aGlzLm1hcCA9IG5ldyBnb29nbGUubWFwcy5NYXAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21hcCcpLCBvcHRpb25zKVxuICAgIHRoaXMubWFya2Vycy5wdXNoKG5ldyBnb29nbGUubWFwcy5NYXJrZXIoe1xuICAgICAgICBwb3NpdGlvbjogeyBsYXQ6IHRoaXMubGF0aXR1ZGUsIGxuZzogdGhpcy5sb25naXR1ZGUgfSxcbiAgICAgICAgbWFwOiB0aGlzLm1hcCxcbiAgICAgICAgYW5pbWF0aW9uOiBnb29nbGUubWFwcy5BbmltYXRpb24uRFJPUFxuICAgICAgfSkpO1xuICAgIH07XG4gICAgdXBkYXRlTWFwQW5kTWFya2VyUG9zaXRpb24gPSBmdW5jdGlvbihsYXQsIGxvbmcpIHtcbiAgICAgIGlmICghaXNOYU4obGF0KSAmJiAhaXNOYU4obG9uZykpIHtcbiAgICAgICAgbGV0IG5ld0NlbnRlciA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmcobGF0LCBsb25nKTtcbiAgICAgICAgdGhpcy5tYXAuc2V0Q2VudGVyKG5ld0NlbnRlcik7XG4gICAgICAgIHRoaXMubWFya2Vyc1swXS5zZXRQb3NpdGlvbihuZXdDZW50ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBhZGRNYXJrZXJzID0gZnVuY3Rpb24obGF0LCBsb25nKXtcbiAgICAgIHRoaXMubWFya2Vycy5mb3JFYWNoKG1hcmtlciA9PiBtYXJrZXIuc2V0TWFwKG51bGwpKVxuICAgICAgdGhpcy5tYXJrZXJzID0gW11cbiAgICAgIGNvbnN0IGJvdW5kcyA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHMoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGF0Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgY29uc3QgbWFya2VyID0gbmV3IGdvb2dsZS5tYXBzLk1hcmtlcih7XG4gICAgICAgICAgcG9zaXRpb246IHsgbGF0OiBsYXRbaV0sIGxuZzogbG9uZ1tpXSB9LFxuICAgICAgICAgIG1hcDogdGhpcy5tYXAsXG4gICAgICAgICAgbGFiZWw6IChpICsgMSkudG9TdHJpbmcoKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXJrZXJzLnB1c2gobWFya2VyKVxuICAgICAgICBib3VuZHMuZXh0ZW5kKG1hcmtlci5nZXRQb3NpdGlvbigpKVxuICAgICAgfVxuICAgICAgdGhpcy5tYXAuZml0Qm91bmRzKGJvdW5kcylcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hcCJdLCJuYW1lcyI6WyJNYXAiLCJjb25zdHJ1Y3RvciIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiX2RlZmluZVByb3BlcnR5Iiwib3B0aW9ucyIsInpvb20iLCJjZW50ZXIiLCJsYXQiLCJsbmciLCJtYXAiLCJnb29nbGUiLCJtYXBzIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsIm1hcmtlcnMiLCJwdXNoIiwiTWFya2VyIiwicG9zaXRpb24iLCJhbmltYXRpb24iLCJBbmltYXRpb24iLCJEUk9QIiwibG9uZyIsImlzTmFOIiwibmV3Q2VudGVyIiwiTGF0TG5nIiwic2V0Q2VudGVyIiwic2V0UG9zaXRpb24iLCJmb3JFYWNoIiwibWFya2VyIiwic2V0TWFwIiwiYm91bmRzIiwiTGF0TG5nQm91bmRzIiwiaSIsImxlbmd0aCIsImxhYmVsIiwidG9TdHJpbmciLCJleHRlbmQiLCJnZXRQb3NpdGlvbiIsImZpdEJvdW5kcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/maps.js\n");

/***/ }),

/***/ "./src/traceroute.js":
/*!***************************!*\
  !*** ./src/traceroute.js ***!
  \***************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nclass Traceroute {\n  constructor() {}\n  async getRoute(name) {\n    const route = await fetch(`http://localhost:5001/traceroute?domain=${name}`);\n    // const route = await fetch(`https://mapping-the-matrix.onrender.com/?domain=${name}`)\n    const data = await route.json();\n    console.log(data);\n    return data;\n  }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (Traceroute);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdHJhY2Vyb3V0ZS5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsVUFBVSxDQUFDO0VBQ2JDLFdBQVdBLENBQUEsRUFBRSxDQUViO0VBQ0EsTUFBTUMsUUFBUUEsQ0FBQ0MsSUFBSSxFQUFDO0lBQ2hCLE1BQU1DLEtBQUssR0FBRyxNQUFNQyxLQUFLLENBQUUsMkNBQTBDRixJQUFLLEVBQUMsQ0FBQztJQUM1RTtJQUNBLE1BQU1HLElBQUksR0FBRyxNQUFNRixLQUFLLENBQUNHLElBQUksRUFBRTtJQUMvQkMsT0FBTyxDQUFDQyxHQUFHLENBQUNILElBQUksQ0FBQztJQUNqQixPQUFPQSxJQUFJO0VBQ2Y7QUFDSjtBQUVBLCtEQUFlTixVQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFwX21hdHJpeC8uL3NyYy90cmFjZXJvdXRlLmpzPzkzNzAiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgVHJhY2Vyb3V0ZSB7XG4gICAgY29uc3RydWN0b3IoKXtcblxuICAgIH1cbiAgICBhc3luYyBnZXRSb3V0ZShuYW1lKXtcbiAgICAgICAgY29uc3Qgcm91dGUgPSBhd2FpdCBmZXRjaChgaHR0cDovL2xvY2FsaG9zdDo1MDAxL3RyYWNlcm91dGU/ZG9tYWluPSR7bmFtZX1gKVxuICAgICAgICAvLyBjb25zdCByb3V0ZSA9IGF3YWl0IGZldGNoKGBodHRwczovL21hcHBpbmctdGhlLW1hdHJpeC5vbnJlbmRlci5jb20vP2RvbWFpbj0ke25hbWV9YClcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJvdXRlLmpzb24oKTtcbiAgICAgICAgY29uc29sZS5sb2coZGF0YSlcbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRyYWNlcm91dGUiXSwibmFtZXMiOlsiVHJhY2Vyb3V0ZSIsImNvbnN0cnVjdG9yIiwiZ2V0Um91dGUiLCJuYW1lIiwicm91dGUiLCJmZXRjaCIsImRhdGEiLCJqc29uIiwiY29uc29sZSIsImxvZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/traceroute.js\n");

/***/ }),

/***/ "./src/index.css":
/*!***********************!*\
  !*** ./src/index.css ***!
  \***********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguY3NzLmpzIiwibWFwcGluZ3MiOiI7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL21hcF9tYXRyaXgvLi9zcmMvaW5kZXguY3NzPzgwNmUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.css\n");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ (function(module) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; };\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) });\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: true });\n  defineProperty(\n    GeneratorFunctionPrototype,\n    \"constructor\",\n    { value: GeneratorFunction, configurable: true }\n  );\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    defineProperty(this, \"_invoke\", { value: enqueue });\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var methodName = context.method;\n    var method = delegate.iterator[methodName];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method, or a missing .next mehtod, always terminate the\n      // yield* loop.\n      context.delegate = null;\n\n      // Note: [\"return\"] must be used for ES3 parsing compatibility.\n      if (methodName === \"throw\" && delegate.iterator[\"return\"]) {\n        // If the delegate iterator has a return method, give it a\n        // chance to clean up.\n        context.method = \"return\";\n        context.arg = undefined;\n        maybeInvokeDelegate(delegate, context);\n\n        if (context.method === \"throw\") {\n          // If maybeInvokeDelegate(context) changed context.method from\n          // \"return\" to \"throw\", let that override the TypeError below.\n          return ContinueSentinel;\n        }\n      }\n      if (methodName !== \"return\") {\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a '\" + methodName + \"' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(val) {\n    var object = Object(val);\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n   true ? module.exports : 0\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLGlEQUFpRDs7QUFFNUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ04sZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx1REFBdUQ7QUFDN0Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxnQkFBZ0I7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxtQkFBbUI7QUFDcEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsS0FBMEIsb0JBQW9CLENBQUU7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFwX21hdHJpeC8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanM/OTZjZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGZ1bmN0aW9uIChvYmosIGtleSwgZGVzYykgeyBvYmpba2V5XSA9IGRlc2MudmFsdWU7IH07XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuICB0cnkge1xuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGRlZmluZVByb3BlcnR5KGdlbmVyYXRvciwgXCJfaW52b2tlXCIsIHsgdmFsdWU6IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkgfSk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgZGVmaW5lUHJvcGVydHkoR3AsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgZGVmaW5lUHJvcGVydHkoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgXCJjb25zdHJ1Y3RvclwiLFxuICAgIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uLCBjb25maWd1cmFibGU6IHRydWUgfVxuICApO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShcbiAgICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSxcbiAgICB0b1N0cmluZ1RhZ1N5bWJvbCxcbiAgICBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgKTtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaW52b2tlXCIsIHsgdmFsdWU6IGVucXVldWUgfSk7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLFxuICAgICAgUHJvbWlzZUltcGxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kTmFtZSA9IGNvbnRleHQubWV0aG9kO1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2ROYW1lXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kLCBvciBhIG1pc3NpbmcgLm5leHQgbWVodG9kLCBhbHdheXMgdGVybWluYXRlIHRoZVxuICAgICAgLy8geWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgIGlmIChtZXRob2ROYW1lID09PSBcInRocm93XCIgJiYgZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1ldGhvZE5hbWUgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ1wiICsgbWV0aG9kTmFtZSArIFwiJyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9KTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHZhciBvYmplY3QgPSBPYmplY3QodmFsKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgaW4gbW9kZXJuIGVuZ2luZXNcbiAgLy8gd2UgY2FuIGV4cGxpY2l0bHkgYWNjZXNzIGdsb2JhbFRoaXMuIEluIG9sZGVyIGVuZ2luZXMgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiKSB7XG4gICAgZ2xvYmFsVGhpcy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xuICB9IGVsc2Uge1xuICAgIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	__webpack_require__("./src/index.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.css");
/******/ 	
/******/ })()
;